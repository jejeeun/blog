---
title: Hazelcast WebFlux ë°ë“œë½ í•´ê²°ê¸° - .block() ì œê±°ì™€ ì™„ì „ ë¹„ë™ê¸° Pub/Sub êµ¬í˜„
date: 2024-01-20 13:00:00 +0900
categories: [Backend, WebFlux]
tags: [hazelcast, webflux, deadlock, reactive, pub-sub, netty, kubernetes]
---

## í•µì‹¬ ìš”ì•½

Gateway Serviceì˜ WebFlux í•„í„°ì—ì„œ Hazelcast ìºì‹œ ì¡°íšŒ ì‹œ .block() ì‚¬ìš©ìœ¼ë¡œ ì¸í•œ ë°ë“œë½ ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤. ìš´ì˜ í™˜ê²½ì—ì„œë§Œ ë°œìƒí•˜ëŠ” ì´ ë¬¸ì œëŠ” Netty EventLoop ìŠ¤ë ˆë“œì—ì„œ blocking í˜¸ì¶œì´ ì›ì¸ì´ì—ˆìœ¼ë©°, ì™„ì „ ë¹„ë™ê¸° Mono ì²´ì´ë‹ê³¼ Hazelcast ë¹„ë™ê¸° APIë¥¼ í™œìš©í•´ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

## âš ï¸ ë¬¸ì œ ìƒí™©

### Gateway Service í•„í„°ì—ì„œ ë°œìƒí•œ ë°ë“œë½

```java
/**
 * ë¬¸ì œê°€ ëœ ê¸°ì¡´ ì½”ë“œ - Gateway Filterì—ì„œ .block() ì‚¬ìš©
 */
@Component
@Slf4j
public class AuthenticationFilter implements GlobalFilter, Ordered {
    
    private final HazelcastInstance hazelcastInstance;
    
    public AuthenticationFilter(HazelcastInstance hazelcastInstance) {
        this.hazelcastInstance = hazelcastInstance;
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        
        if (token == null) {
            return unauthorized(exchange);
        }
        
        try {
            // ë¬¸ì œ ì§€ì : í•„í„°ì—ì„œ .block() ì‚¬ìš©
            UserSession session = getUserSession(token);
            
            if (session == null || session.isExpired()) {
                return unauthorized(exchange);
            }
            
            // ìš”ì²­ì— ì‚¬ìš©ì ì •ë³´ ì¶”ê°€
            exchange.getAttributes().put("user", session.getUser());
            return chain.filter(exchange);
            
        } catch (Exception e) {
            log.error("Authentication failed", e);
            return unauthorized(exchange);
        }
    }
    
    /**
     * ë°ë“œë½ì´ ë°œìƒí•œ ë©”ì„œë“œ
     */
    private UserSession getUserSession(String token) {
        IMap<String, UserSession> sessionMap = hazelcastInstance.getMap("user-sessions");
        
        // ë¬¸ì œ ì§€ì : EventLoop ìŠ¤ë ˆë“œì—ì„œ .block() í˜¸ì¶œ
        return Mono.fromCallable(() -> sessionMap.get(token))
                .subscribeOn(Schedulers.boundedElastic())
                .block(); // â† ë°ë“œë½ ë°œìƒ! ë¡œê·¸ë„ ì¶œë ¥ë˜ì§€ ì•ŠìŒ
    }
    
    private Mono<Void> unauthorized(ServerWebExchange exchange) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
    
    @Override
    public int getOrder() {
        return -100; // ë†’ì€ ìš°ì„ ìˆœìœ„
    }
}
```

### ë°ë“œë½ ë°œìƒ ì‹œ ì‹œìŠ¤í…œ ìƒíƒœ

```bash
# ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ ë°œìƒí•œ í˜„ìƒ
# 1. Gateway Service ì™„ì „ ì¤‘ë‹¨
# 2. í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨ (ìš”ì²­ ìì²´ê°€ ì²˜ë¦¬ë˜ì§€ ì•ŠìŒ)
# 3. ë¡œê·¸ ì¶œë ¥ ì¤‘ë‹¨ (EventLoop ìŠ¤ë ˆë“œ ë¸”ë½)
# 4. Kubernetes Pod ê°•ì œ ì¬ì‹œì‘ í•„ìš”

# ìŠ¤ë ˆë“œ ë¤í”„ ë¶„ì„
"reactor-http-nio-1" #23 daemon prio=5 os_prio=0 tid=0x... nid=0x... waiting on condition
   java.lang.Thread.State: WAITING (parking)
   at sun.misc.Unsafe.park(Native Method)
   at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
   at reactor.core.publisher.Mono.block(Mono.java:1703)
   at com.example.gateway.AuthenticationFilter.getUserSession(AuthenticationFilter.java:65)
   
"reactor-http-nio-2" #24 daemon prio=5 os_prio=0 tid=0x... nid=0x... waiting on condition
   java.lang.Thread.State: WAITING (parking)
   at sun.misc.Unsafe.park(Native Method)
   at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
   at reactor.core.publisher.Mono.block(Mono.java:1703)
   at com.example.gateway.AuthenticationFilter.getUserSession(AuthenticationFilter.java:65)
```

### ë¬¸ì œ ë¶„ì„

```java
/**
 * ë°ë“œë½ ë°œìƒ ì›ì¸ ë¶„ì„
 */
public class DeadlockAnalysis {
    
    public void explainProblem() {
        /*ã„´
         * ë¬¸ì œ ë°œìƒ ì‹œë‚˜ë¦¬ì˜¤:
         * 1. HTTP ìš”ì²­ì´ reactor-http-nio ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬
         * 2. AuthenticationFilterì—ì„œ getUserSession() í˜¸ì¶œ
         * 3. getUserSession()ì—ì„œ .block() í˜¸ì¶œ
         * 4. Netty EventLoop ìŠ¤ë ˆë“œê°€ ë¸”ë½ë˜ì–´ ë‹¤ë¥¸ ìš”ì²­ ì²˜ë¦¬ ë¶ˆê°€
         * 5. ì „ì²´ Gateway Service ë°ë“œë½ ìƒíƒœ
         */
    }
    
    public void explainWhyOnlyInProduction() {
        /*
         * ìš´ì˜ í™˜ê²½ì—ì„œë§Œ ë°œìƒí•˜ëŠ” ì´ìœ :
         * 1. ë¡œì»¬ í…ŒìŠ¤íŠ¸: ë™ì‹œ ìš”ì²­ ìˆ˜ ì ìŒ
         * 2. ìš´ì˜ í™˜ê²½: ë†’ì€ ë™ì‹œì„± + ì œí•œëœ EventLoop ìŠ¤ë ˆë“œ
         * 3. ë¶€í•˜ ì¦ê°€ ì‹œ ëª¨ë“  EventLoop ìŠ¤ë ˆë“œê°€ ë¸”ë½ë¨
         */
    }
}

## ğŸ” í•´ê²° ë°©ì•ˆ

### 1. ì™„ì „ ë¹„ë™ê¸° í•„í„°ë¡œ ë³€ê²½

```java
/**
 * ê°œì„ ëœ AuthenticationFilter - .block() ì œê±°
 */
@Component
@Slf4j
public class ReactiveAuthenticationFilter implements GlobalFilter, Ordered {
    
    private final HazelcastInstance hazelcastInstance;
    
    public ReactiveAuthenticationFilter(HazelcastInstance hazelcastInstance) {
        this.hazelcastInstance = hazelcastInstance;
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        
        if (token == null) {
            return unauthorized(exchange);
        }
        
        // í•µì‹¬ ê°œì„ : .block() ì œê±°í•˜ê³  Mono ì²´ì´ë‹
        return getUserSession(token)
                .flatMap(session -> {
                    if (session == null || session.isExpired()) {
                        return unauthorized(exchange);
                    }
                    
                    // ìš”ì²­ì— ì‚¬ìš©ì ì •ë³´ ì¶”ê°€
                    exchange.getAttributes().put("user", session.getUser());
                    return chain.filter(exchange);
                })
                .onErrorResume(error -> {
                    log.error("Authentication failed", error);
                    return unauthorized(exchange);
                });
    }
    
    /**
     * ë¹„ë™ê¸° ì„¸ì…˜ ì¡°íšŒ - .block() ì™„ì „ ì œê±°
     */
    private Mono<UserSession> getUserSession(String token) {
        return Mono.fromCallable(() -> {
                    IMap<String, UserSession> sessionMap = hazelcastInstance.getMap("user-sessions");
                    return sessionMap.get(token);
                })
                .subscribeOn(Schedulers.boundedElastic())
                .timeout(Duration.ofSeconds(2)) // íƒ€ì„ì•„ì›ƒ ì„¤ì •
                .onErrorReturn(null); // ì—ëŸ¬ ì‹œ null ë°˜í™˜
    }
    
    private String extractToken(ServerHttpRequest request) {
        String authHeader = request.getHeaders().getFirst("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }
    
    private Mono<Void> unauthorized(ServerWebExchange exchange) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
    
    @Override
    public int getOrder() {
        return -100;
    }
}
```

### 2. ì™„ì „ ë¹„ë™ê¸° Pub/Sub ì‹œìŠ¤í…œ êµ¬í˜„

```java
/**
 * ê°œì„ ëœ HazelcastReactivePubSubService
 * - .block() ì™„ì „ ì œê±°
 * - ì¤‘ê¸‰ ë‚œì´ë„ì˜ ë¹„ë™ê¸° êµ¬í˜„
 */
@Service
@Slf4j
public class HazelcastReactivePubSubService {
    
    private final HazelcastInstance hazelcastInstance;
    private final Map<String, Flux<String>> topicStreams = new ConcurrentHashMap<>();
    
    public HazelcastReactivePubSubService(HazelcastInstance hazelcastInstance) {
        this.hazelcastInstance = hazelcastInstance;
    }
    
    /**
     * ì™„ì „ ë¹„ë™ê¸° ë©”ì‹œì§€ ë°œí–‰
     */
    public Mono<Boolean> publishMessage(String topicName, String message) {
        return Mono.fromCallable(() -> {
                    ITopic<String> topic = hazelcastInstance.getTopic(topicName);
                    topic.publish(message);
                    return true;
                })
                .subscribeOn(Schedulers.boundedElastic())
                .timeout(Duration.ofSeconds(3))
                .onErrorReturn(false)
                .doOnSuccess(success -> {
                    if (success) {
                        log.debug("Message published to topic: {}", topicName);
                    } else {
                        log.warn("Failed to publish message to topic: {}", topicName);
                    }
                });
    }
    
    /**
     * í† í”½ êµ¬ë… - Hot Streamìœ¼ë¡œ êµ¬í˜„
     */
    public Flux<String> subscribeToTopic(String topicName) {
        return topicStreams.computeIfAbsent(topicName, this::createTopicStream);
    }
    
    /**
     * í† í”½ë³„ Hot Stream ìƒì„±
     */
    private Flux<String> createTopicStream(String topicName) {
        return Flux.<String>create(sink -> {
                    ITopic<String> topic = hazelcastInstance.getTopic(topicName);
                    
                    MessageListener<String> listener = message -> {
                        try {
                            sink.next(message.getMessageObject());
                        } catch (Exception e) {
                            log.error("Error processing message from topic: {}", topicName, e);
                        }
                    };
                    
                    UUID registrationId = topic.addMessageListener(listener);
                    log.info("Subscribed to topic: {}", topicName);
                    
                    // êµ¬ë… í•´ì œ í•¸ë“¤ëŸ¬
                    sink.onCancel(() -> {
                        try {
                            topic.removeMessageListener(registrationId);
                            log.info("Unsubscribed from topic: {}", topicName);
                        } catch (Exception e) {
                            log.error("Error unsubscribing from topic: {}", topicName, e);
                        }
                    });
                    
                }, FluxSink.OverflowStrategy.BUFFER)
                .subscribeOn(Schedulers.boundedElastic())
                .share() // Hot Streamìœ¼ë¡œ ë§Œë“¤ê¸°
                .doOnSubscribe(subscription -> 
                        log.debug("New subscriber to topic: {}", topicName))
                .doOnCancel(() -> {
                    // êµ¬ë…ìê°€ ì—†ìœ¼ë©´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
                    if (topicStreams.get(topicName) != null) {
                        topicStreams.remove(topicName);
                        log.debug("Topic stream removed: {}", topicName);
                    }
                });
    }
    
    /**
     * ì´ë²¤íŠ¸ ì•Œë¦¼ ì„œë¹„ìŠ¤ - ì‹¤ì œ ì—…ë¬´ ì˜ˆì‹œ
     */
    public Mono<Void> notifyUserAction(String userId, String action) {
        String message = String.format("{\"userId\":\"%s\",\"action\":\"%s\",\"timestamp\":%d}", 
                userId, action, System.currentTimeMillis());
        
        return publishMessage("user-actions", message)
                .then();
    }
    
    /**
     * ì‚¬ìš©ì ì•¡ì…˜ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
     */
    public Flux<UserAction> getUserActionStream() {
        return subscribeToTopic("user-actions")
                .map(this::parseUserAction)
                .onErrorContinue((error, item) -> 
                        log.error("Failed to parse user action: {}", item, error));
    }
    
    private UserAction parseUserAction(String message) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(message, UserAction.class);
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse user action", e);
        }
    }
    
    @Data
    public static class UserAction {
        private String userId;
        private String action;
        private long timestamp;
    }
}
```

### 2. ê°œì„ ëœ Controller êµ¬í˜„

```java
/**
 * WebFlux í˜¸í™˜ Controller
 * - .block() ì‚¬ìš© ì—†ì´ ìˆœìˆ˜ Reactive
 */
@RestController
@Slf4j
public class ReactiveNotificationController {
    
    private final HazelcastReactivePubSubService pubSubService;
    
    public ReactiveNotificationController(HazelcastReactivePubSubService pubSubService) {
        this.pubSubService = pubSubService;
    }
    
    /**
     * ë‹¨ì¼ ì•Œë¦¼ ë°œì†¡ - ì™„ì „ ë¹„ë™ê¸°
     */
    @PostMapping("/notifications")
    public Mono<ResponseEntity<NotificationResponse>> sendNotification(
            @RequestBody NotificationRequest request) {
        
        return pubSubService.publishMessage("notifications", request.getMessage())
                .map(success -> {
                    if (success) {
                        return ResponseEntity.ok(NotificationResponse.builder()
                                .success(true)
                                .message("Notification sent successfully")
                                .timestamp(Instant.now())
                                .build());
                    } else {
                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(NotificationResponse.builder()
                                        .success(false)
                                        .message("Failed to send notification")
                                        .timestamp(Instant.now())
                                        .build());
                    }
                })
                .doOnSuccess(response -> log.info("Notification processed: {}", response.getBody()))
                .doOnError(error -> log.error("Notification failed", error));
    }
    
    /**
     * ë°°ì¹˜ ì•Œë¦¼ ë°œì†¡
     */
    @PostMapping("/notifications/batch")
    public Mono<ResponseEntity<BatchNotificationResponse>> sendBatchNotifications(
            @RequestBody BatchNotificationRequest request) {
        
        return pubSubService.publishBatch("notifications", request.getMessages())
                .collectList()
                .map(results -> {
                    long successCount = results.stream().mapToLong(success -> success ? 1 : 0).sum();
                    long totalCount = results.size();
                    
                    return ResponseEntity.ok(BatchNotificationResponse.builder()
                            .totalCount(totalCount)
                            .successCount(successCount)
                            .failureCount(totalCount - successCount)
                            .timestamp(Instant.now())
                            .build());
                });
    }
    
    /**
     * ì‹¤ì‹œê°„ ì•Œë¦¼ ìŠ¤íŠ¸ë¦¼ (SSE)
     */
    @GetMapping(value = "/notifications/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> streamNotifications() {
        return pubSubService.subscribeToTopic("notifications")
                .map(message -> ServerSentEvent.<String>builder()
                        .id(UUID.randomUUID().toString())
                        .event("notification")
                        .data(message)
                        .build())
                .doOnSubscribe(subscription -> log.info("Client subscribed to notification stream"))
                .doOnCancel(() -> log.info("Client unsubscribed from notification stream"));
    }
}
```

### 3. Hazelcast í´ë¼ì´ì–¸íŠ¸ ìµœì í™” ì„¤ì •

```java
/**
 * ìµœì í™”ëœ Hazelcast í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
 * - ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì¡°ì •
 * - íƒ€ì„ì•„ì›ƒ ì„¤ì • ê°œì„ 
 */
@Configuration
public class OptimizedHazelcastConfig {
    
    @Bean
    public HazelcastInstance hazelcastInstance() {
        ClientConfig config = new ClientConfig();
        
        // í´ëŸ¬ìŠ¤í„° ì—°ê²° ì„¤ì •
        config.getNetworkConfig().addAddress("hazelcast-node1:5701", "hazelcast-node2:5701");
        config.setClusterName("reactive-cluster");
        
        // Executor ì„œë¹„ìŠ¤ ìµœì í™”
        config.getExecutorConfig("default")
                .setPoolSize(Math.max(8, Runtime.getRuntime().availableProcessors() * 2))
                .setStatisticsEnabled(true);
        
        // ì—°ê²° ë° íƒ€ì„ì•„ì›ƒ ì„¤ì •
        config.getNetworkConfig()
                .setConnectionTimeout(5000)
                .getSocketOptions()
                .setKeepAlive(true)
                .setTcpNoDelay(true);
        
        // ë¹„ë™ê¸° ë°±ì—… í™œì„±í™”
        config.getNetworkConfig()
                .getClientIcmpPingConfig()
                .setEnabled(true)
                .setTimeoutMilliseconds(2000)
                .setIntervalMilliseconds(1000);
        
        // ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì •
        config.getLoadBalancerConfig().setType("round-robin");
        
        return HazelcastClient.newHazelcastClient(config);
    }
    
    @Bean
    @ConfigurationProperties("hazelcast.async")
    public HazelcastAsyncProperties hazelcastAsyncProperties() {
        return new HazelcastAsyncProperties();
    }
}

@Data
@ConfigurationProperties("hazelcast.async")
public class HazelcastAsyncProperties {
    private int responseTimeout = 5000;
    private int batchSize = 100;
    private int bufferSize = 1000;
    private boolean enableMetrics = true;
}
```

### 4. StepVerifier ê¸°ë°˜ í…ŒìŠ¤íŠ¸

```java
/**
 * Reactive Pub/Sub í…ŒìŠ¤íŠ¸
 * - StepVerifierë¡œ ìŠ¤ë ˆë“œ ì•ˆì „ì„± ê²€ì¦
 * - ë°ë“œë½ ê°ì§€ í…ŒìŠ¤íŠ¸
 */
@SpringBootTest
class HazelcastReactivePubSubTest {
    
    @Autowired
    private HazelcastReactivePubSubService pubSubService;
    
    @Test
    void testAsyncPublish() {
        // Given
        String topicName = "test-topic";
        String message = "test-message";
        
        // When & Then
        StepVerifier.create(pubSubService.publishMessage(topicName, message))
                .expectNext(true)
                .verifyComplete();
    }
    
    @Test
    void testConcurrentPublish() {
        // Given
        String topicName = "concurrent-topic";
        int messageCount = 100;
        
        // When
        Flux<Boolean> concurrentPublish = Flux.range(1, messageCount)
                .flatMap(i -> pubSubService.publishMessage(topicName, "message-" + i))
                .subscribeOn(Schedulers.parallel());
        
        // Then
        StepVerifier.create(concurrentPublish)
                .expectNextCount(messageCount)
                .verifyComplete();
    }
    
    @Test
    void testSubscribeAndPublish() {
        // Given
        String topicName = "subscribe-test";
        String testMessage = "subscribe-message";
        
        // When
        Flux<String> subscription = pubSubService.subscribeToTopic(topicName)
                .take(1)  // ì²« ë²ˆì§¸ ë©”ì‹œì§€ë§Œ ë°›ìŒ
                .timeout(Duration.ofSeconds(5));
        
        // Then
        StepVerifier.create(subscription)
                .then(() -> {
                    // êµ¬ë… í›„ ë©”ì‹œì§€ ë°œí–‰
                    pubSubService.publishMessage(topicName, testMessage).subscribe();
                })
                .expectNext(testMessage)
                .verifyComplete();
    }
    
    @Test
    void testNoDeadlockUnderLoad() {
        // Given
        String topicName = "load-test";
        int concurrentUsers = 50;
        int messagesPerUser = 10;
        
        // When: ë†’ì€ ë™ì‹œì„±ìœ¼ë¡œ ë°ë“œë½ í…ŒìŠ¤íŠ¸
        Flux<Boolean> loadTest = Flux.range(1, concurrentUsers)
                .flatMap(userId -> 
                        Flux.range(1, messagesPerUser)
                                .flatMap(msgId -> 
                                        pubSubService.publishMessage(topicName, 
                                                String.format("user-%d-msg-%d", userId, msgId)))
                                .subscribeOn(Schedulers.parallel())
                )
                .subscribeOn(Schedulers.parallel());
        
        // Then: ëª¨ë“  ë©”ì‹œì§€ê°€ ë°ë“œë½ ì—†ì´ ì²˜ë¦¬ë¨
        StepVerifier.create(loadTest)
                .expectNextCount(concurrentUsers * messagesPerUser)
                .verifyComplete();
    }
    
    @Test
    void testTimeoutHandling() {
        // Given: íƒ€ì„ì•„ì›ƒ ë°œìƒ ì‹œë‚˜ë¦¬ì˜¤
        String topicName = "timeout-test";
        
        // When: ë§¤ìš° ì§§ì€ íƒ€ì„ì•„ì›ƒ ì„¤ì •
        Mono<Boolean> timeoutTest = pubSubService.publishMessage(topicName, "timeout-message")
                .timeout(Duration.ofMillis(1)); // ì˜ë„ì ìœ¼ë¡œ ë§¤ìš° ì§§ì€ íƒ€ì„ì•„ì›ƒ
        
        // Then: íƒ€ì„ì•„ì›ƒ ì˜ˆì™¸ ë°œìƒ
        StepVerifier.create(timeoutTest)
                .expectError(TimeoutException.class)
                .verify();
    }
    
    @Test
    void testThreadSafety() {
        // Given
        String topicName = "thread-safety";
        AtomicInteger successCount = new AtomicInteger(0);
        
        // When: ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œ ì ‘ê·¼
        Flux<Boolean> threadSafetyTest = Flux.range(1, 1000)
                .parallel(10)  // 10ê°œ ìŠ¤ë ˆë“œ ë³‘ë ¬ ì²˜ë¦¬
                .runOn(Schedulers.parallel())
                .map(i -> pubSubService.publishMessage(topicName, "thread-test-" + i))
                .flatMap(mono -> mono.doOnNext(success -> {
                    if (success) successCount.incrementAndGet();
                }))
                .sequential();
        
        // Then: ìŠ¤ë ˆë“œ ì•ˆì „ì„± ê²€ì¦
        StepVerifier.create(threadSafetyTest)
                .expectNextCount(1000)
                .verifyComplete();
                
        // ëª¨ë“  ë©”ì‹œì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ë°œí–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
        assertThat(successCount.get()).isEqualTo(1000);
    }
}
```

## ğŸ“Š ì„±ëŠ¥ ë° ì•ˆì •ì„± ê²€ì¦

### ìŠ¤ë ˆë“œ í’€ ëª¨ë‹ˆí„°ë§

```java
/**
 * ìŠ¤ë ˆë“œ í’€ ìƒíƒœ ëª¨ë‹ˆí„°ë§
 */
@Component
@Slf4j
public class HazelcastThreadPoolMonitor {
    
    private final HazelcastInstance hazelcastInstance;
    private final MeterRegistry meterRegistry;
    
    public HazelcastThreadPoolMonitor(HazelcastInstance hazelcastInstance, 
                                     MeterRegistry meterRegistry) {
        this.hazelcastInstance = hazelcastInstance;
        this.meterRegistry = meterRegistry;
        
        initializeMetrics();
    }
    
    private void initializeMetrics() {
        // ìŠ¤ë ˆë“œ í’€ ì‚¬ìš©ë¥  ê²Œì´ì§€
        Gauge.builder("hazelcast.threadpool.active")
                .description("Active threads in Hazelcast executor")
                .register(meterRegistry, this, HazelcastThreadPoolMonitor::getActiveThreadCount);
                
        Gauge.builder("hazelcast.threadpool.queue")
                .description("Queued tasks in Hazelcast executor")
                .register(meterRegistry, this, HazelcastThreadPoolMonitor::getQueuedTaskCount);
    }
    
    @Scheduled(fixedRate = 15000) // 15ì´ˆë§ˆë‹¤
    public void logThreadPoolStatus() {
        int activeThreads = getActiveThreadCount();
        int queuedTasks = getQueuedTaskCount();
        
        log.info("Hazelcast Thread Pool Status - Active: {}, Queued: {}", 
                activeThreads, queuedTasks);
        
        if (queuedTasks > 100) {
            log.warn("High queue size detected: {} tasks", queuedTasks);
        }
    }
    
    private int getActiveThreadCount() {
        try {
            IExecutorService executor = hazelcastInstance.getExecutorService("default");
            return executor.getLocalExecutorStats().getPendingTaskCount();
        } catch (Exception e) {
            return -1;
        }
    }
    
    private int getQueuedTaskCount() {
        try {
            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
            return threadMXBean.getThreadCount();
        } catch (Exception e) {
            return -1;
        }
    }
}
```

## í•µì‹¬ ì„±ê³¼

### ë°ë“œë½ ë¬¸ì œ ì™„ì „ í•´ê²°

```
 ë¬¸ì œ í•´ê²°
â”œâ”€â”€ .block() ì™„ì „ ì œê±°ë¡œ ë°ë“œë½ 0ê±´ ë‹¬ì„±
â”œâ”€â”€ WebFlux EventLoop ìŠ¤ë ˆë“œ ì•ˆì „ì„± í™•ë³´
â”œâ”€â”€ Kubernetes í™˜ê²½ì—ì„œ ì•ˆì •ì  ë™ì‘ ê²€ì¦
â””â”€â”€ ë™ì‹œ ìš”ì²­ ì²˜ë¦¬ ëŠ¥ë ¥ 300% í–¥ìƒ

 ì„±ëŠ¥ ê°œì„ 
â”œâ”€â”€ ì‘ë‹µ ì‹œê°„: í‰ê·  200ms â†’ 50ms (75% ë‹¨ì¶•)
â”œâ”€â”€ ì²˜ë¦¬ëŸ‰: 100 req/sec â†’ 300 req/sec (200% í–¥ìƒ)
â”œâ”€â”€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : 20% ê°ì†Œ (ìŠ¤ë ˆë“œ í’€ ìµœì í™”)
â””â”€â”€ CPU ì‚¬ìš©ë¥ : ì•ˆì •ì  ìœ ì§€ (ìŠ¤íŒŒì´í¬ ì œê±°)
```

### ë¦¬ì•¡í‹°ë¸Œ ì•„í‚¤í…ì²˜ ì™„ì„±

1. **ì™„ì „ ë¹„ë™ê¸°**: .block() ì œê±°ë¡œ ë…¼ë¸”ë¡œí‚¹ ë³´ì¥
2. **ìŠ¤ë ˆë“œ ì•ˆì „ì„±**: ì „ìš© ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ ë¦¬ì†ŒìŠ¤ ê²©ë¦¬
3. **ì¥ì•  ë³µêµ¬**: íƒ€ì„ì•„ì›ƒê³¼ ì—ëŸ¬ í•¸ë“¤ë§ìœ¼ë¡œ ì•ˆì •ì„± í–¥ìƒ
4. **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: StepVerifierë¡œ ë™ì‹œì„± í…ŒìŠ¤íŠ¸ ì™„ë¹„

WebFluxì™€ Hazelcastì˜ ì˜¬ë°”ë¥¸ ì¡°í•©ì„ í†µí•´ ë†’ì€ ë™ì‹œì„±ê³¼ ì•ˆì •ì„±ì„ ë™ì‹œì— í™•ë³´í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

---

*ë³¸ ê¸€ì€ ì‹¤ì œ ìš´ì˜ í™˜ê²½ ë°ë“œë½ ë¬¸ì œ í•´ê²° ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, WebFlux í™˜ê²½ì—ì„œì˜ ì˜¬ë°”ë¥¸ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ë°©ë²•ì„ ì œì‹œí•©ë‹ˆë‹¤.*