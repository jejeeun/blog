---
title: Hazelcast WebFlux ë°ë“œë½ í•´ê²°ê¸° - .block() ì œê±°ì™€ ì™„ì „ ë¹„ë™ê¸° Pub/Sub êµ¬í˜„
date: 2024-01-20 13:00:00 +0900
categories: [Backend, WebFlux]
tags: [hazelcast, webflux, deadlock, reactive, pub-sub, netty, kubernetes]
---

## í•µì‹¬ ìš”ì•½

Hazelcast Topic.publishì™€ WebFlux ê²°í•© ì‹œ .block()ì—ì„œ ë°œìƒí•˜ëŠ” ë°ë“œë½ ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œëŠ” ì¬í˜„ë˜ì§€ ì•Šê³  ìš´ì˜ Kubernetes í™˜ê²½ì—ì„œë§Œ ë°œìƒí•˜ëŠ” ì´ìŠˆë¥¼ ë¶„ì„í•˜ì—¬ WebFlux Netty EventLoop ìŠ¤ë ˆë“œ ì œì•½ê³¼ Hazelcast í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œ í’€ ë¶€ì¡±ì´ ì›ì¸ì„ì„ íŒŒì•…í–ˆê³ , ì™„ì „ ë¹„ë™ê¸° Flux ë¦¬íŒ©í„°ë§ê³¼ StepVerifier ê¸°ë°˜ í…ŒìŠ¤íŠ¸ë¡œ ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

## âš ï¸ ë¬¸ì œ ìƒí™©

### ìš´ì˜ í™˜ê²½ì—ì„œë§Œ ë°œìƒí•˜ëŠ” ë°ë“œë½

```java
/**
 * ë¬¸ì œê°€ ëœ ê¸°ì¡´ ì½”ë“œ - .block() ì‚¬ìš©
 */
@Service
@Slf4j
public class HazelcastPubSubService {
    
    private final HazelcastInstance hazelcastInstance;
    
    public HazelcastPubSubService(HazelcastInstance hazelcastInstance) {
        this.hazelcastInstance = hazelcastInstance;
    }
    
    /**
     * ë°ë“œë½ì´ ë°œìƒí•œ ë©”ì‹œì§€ ë°œí–‰ ë©”ì„œë“œ
     */
    public void publishMessage(String topicName, String message) {
        ITopic<String> topic = hazelcastInstance.getTopic(topicName);
        
        // ë¬¸ì œ ì§€ì : WebFlux í™˜ê²½ì—ì„œ .block() ì‚¬ìš©
        Mono.fromCallable(() -> {
                    topic.publish(message); // Hazelcast ë™ê¸° í˜¸ì¶œ
                    return true;
                })
                .subscribeOn(Schedulers.boundedElastic())
                .block(); // â† ë°ë“œë½ ë°œìƒ ì§€ì 
                
        log.info("Message published: {}", message);
    }
    
    /**
     * WebFlux Controllerì—ì„œ í˜¸ì¶œ
     */
    @RestController
    public class NotificationController {
        
        private final HazelcastPubSubService pubSubService;
        
        @PostMapping("/notifications")
        public Mono<ResponseEntity<String>> sendNotification(@RequestBody NotificationRequest request) {
            return Mono.fromCallable(() -> {
                        // ì—¬ê¸°ì„œ ë°ë“œë½ ë°œìƒ
                        pubSubService.publishMessage("notifications", request.getMessage());
                        return ResponseEntity.ok("Notification sent");
                    })
                    .subscribeOn(Schedulers.boundedElastic());
        }
    }
}
```

### í™˜ê²½ë³„ ì¬í˜„ì„± ì°¨ì´

```yaml
# í…ŒìŠ¤íŠ¸ í™˜ê²½ (ì •ìƒ ë™ì‘)
test:
  environment: local
  threads: unlimited
  hazelcast:
    client:
      executor-service:
        pool-size: 16
        
# ìš´ì˜ í™˜ê²½ (ë°ë“œë½ ë°œìƒ)  
production:
  environment: kubernetes
  pod:
    cpu: "1000m"
    memory: "2Gi"
  hazelcast:
    client:
      executor-service:
        pool-size: 4    # ì œí•œëœ ìŠ¤ë ˆë“œ í’€
```

### ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¶„ì„

```bash
# Kubernetes Podì—ì„œ ë°œìƒí•œ ìŠ¤ë ˆë“œ ë¤í”„
"reactor-http-nio-2" #34 daemon prio=5 os_prio=0 tid=0x... nid=0x... waiting on condition
   java.lang.Thread.State: WAITING (parking)
   at sun.misc.Unsafe.park(Native Method)
   at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
   at reactor.core.publisher.Mono.block(Mono.java:1703)
   
"hazelcast.client.internal-1" #45 daemon prio=5 os_prio=0 tid=0x... nid=0x... waiting for monitor entry
   java.lang.Thread.State: BLOCKED (on object monitor)
   at com.hazelcast.client.impl.protocol.ClientMessage.writeTo(ClientMessage.java:89)
   
# EventLoop ìŠ¤ë ˆë“œì—ì„œ .block() í˜¸ì¶œë¡œ ì¸í•œ ë°ë“œë½
```

## ğŸ” ë¬¸ì œ ë¶„ì„

### 1. WebFlux Netty EventLoop íŠ¹ì„±

```java
/**
 * WebFlux EventLoop ìŠ¤ë ˆë“œ ë¶„ì„
 */
public class WebFluxEventLoopAnalysis {
    
    public void explainEventLoopConstraints() {
        /*
         * Netty EventLoop ì œì•½ì‚¬í•­:
         * 1. EventLoop ìŠ¤ë ˆë“œì—ì„œ blocking í˜¸ì¶œ ê¸ˆì§€
         * 2. .block() í˜¸ì¶œ ì‹œ IllegalStateException ë˜ëŠ” ë°ë“œë½
         * 3. íŠ¹íˆ I/O ì‘ì—…ê³¼ ê²°í•© ì‹œ ì‹¬ê°í•œ ì„±ëŠ¥ ì €í•˜
         */
    }
    
    public void identifyProblemScenario() {
        /*
         * ë¬¸ì œ ë°œìƒ ì‹œë‚˜ë¦¬ì˜¤:
         * 1. HTTP ìš”ì²­ì´ reactor-http-nio ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬
         * 2. Controllerì—ì„œ .block() í˜¸ì¶œ
         * 3. EventLoop ìŠ¤ë ˆë“œê°€ blocking ìƒíƒœë¡œ ì§„ì…
         * 4. ë‹¤ë¥¸ ìš”ì²­ ì²˜ë¦¬ ë¶ˆê°€ëŠ¥í•œ ë°ë“œë½ ìƒíƒœ
         */
    }
}
```

### 2. Hazelcast í´ë¼ì´ì–¸íŠ¸ ìŠ¤ë ˆë“œ í’€ ë¶€ì¡±

```java
/**
 * Hazelcast í´ë¼ì´ì–¸íŠ¸ ì„¤ì • ë¶„ì„
 */
@Configuration
public class HazelcastClientAnalysis {
    
    public void analyzeThreadPoolIssue() {
        /*
         * ìš´ì˜ í™˜ê²½ ë¬¸ì œì :
         * 1. Kubernetes ë¦¬ì†ŒìŠ¤ ì œì•½ìœ¼ë¡œ ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì œí•œ
         * 2. ë™ì‹œ ìš”ì²­ ì¦ê°€ ì‹œ ìŠ¤ë ˆë“œ ê³ ê°ˆ
         * 3. .block() í˜¸ì¶œì´ ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œë“¤ê³¼ ê²½í•©
         */
    }
    
    public void explainTestVsProduction() {
        /*
         * í…ŒìŠ¤íŠ¸ vs ìš´ì˜ í™˜ê²½ ì°¨ì´:
         * - í…ŒìŠ¤íŠ¸: ì¶©ë¶„í•œ ìŠ¤ë ˆë“œ + ë‚®ì€ ë™ì‹œì„±
         * - ìš´ì˜: ì œí•œëœ ìŠ¤ë ˆë“œ + ë†’ì€ ë™ì‹œì„±
         * â†’ ìš´ì˜ì—ì„œë§Œ ìŠ¤ë ˆë“œ ê²½í•©ê³¼ ë°ë“œë½ ë°œìƒ
         */
    }
}
```

### 3. ìŠ¤ë ˆë“œ ìƒíƒœ ëª¨ë‹ˆí„°ë§

```java
/**
 * ë°ë“œë½ ìƒí™© ëª¨ë‹ˆí„°ë§
 */
@Component
@Slf4j
public class ThreadDeadlockDetector {
    
    private final ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    
    @Scheduled(fixedRate = 30000) // 30ì´ˆë§ˆë‹¤ ì²´í¬
    public void detectDeadlocks() {
        long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
        
        if (deadlockedThreads != null) {
            ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreads);
            
            log.error("ğŸš¨ DEADLOCK DETECTED!");
            for (ThreadInfo threadInfo : threadInfos) {
                log.error("Deadlocked thread: {} - {}", 
                         threadInfo.getThreadName(), threadInfo.getThreadState());
                log.error("Stack trace: {}", Arrays.toString(threadInfo.getStackTrace()));
            }
            
            // ì•Œë¦¼ ë°œì†¡
            sendDeadlockAlert(threadInfos);
        }
    }
    
    private void sendDeadlockAlert(ThreadInfo[] threadInfos) {
        // Slack, ì´ë©”ì¼ ë“±ìœ¼ë¡œ ê¸´ê¸‰ ì•Œë¦¼
        String message = String.format("Deadlock detected with %d threads", threadInfos.length);
        // alertService.sendCriticalAlert("Thread Deadlock", message);
    }
}
```

## âœ… í•´ê²° ë°©ì•ˆ

### 1. ì™„ì „ ë¹„ë™ê¸° Pub/Sub ë¦¬íŒ©í„°ë§

```java
/**
 * ê°œì„ ëœ HazelcastReactivePubSubService
 * - .block() ì™„ì „ ì œê±°
 * - ìˆœìˆ˜ Reactive êµ¬í˜„
 */
@Service
@Slf4j
public class HazelcastReactivePubSubService {
    
    private final HazelcastInstance hazelcastInstance;
    private final Scheduler hazelcastScheduler;
    
    @Value("${hazelcast.async.response-timeout:5000}")
    private int asyncResponseTimeout;
    
    public HazelcastReactivePubSubService(HazelcastInstance hazelcastInstance) {
        this.hazelcastInstance = hazelcastInstance;
        
        // Hazelcast ì „ìš© ìŠ¤ì¼€ì¤„ëŸ¬ ìƒì„±
        this.hazelcastScheduler = Schedulers.newBoundedElastic(
                Runtime.getRuntime().availableProcessors() * 2,
                Integer.MAX_VALUE,
                "hazelcast-reactive",
                60,
                true
        );
    }
    
    /**
     * ì™„ì „ ë¹„ë™ê¸° ë©”ì‹œì§€ ë°œí–‰
     * .block() ì œê±°í•˜ê³  Mono ë°˜í™˜
     */
    public Mono<Boolean> publishMessage(String topicName, String message) {
        return Mono.fromCallable(() -> {
                    try {
                        ITopic<String> topic = hazelcastInstance.getTopic(topicName);
                        
                        // CompletableFutureë¡œ ë¹„ë™ê¸° ì²˜ë¦¬
                        CompletableFuture<Void> publishFuture = CompletableFuture.runAsync(() -> {
                            try {
                                topic.publish(message);
                                log.debug("Message published to topic: {}", topicName);
                            } catch (Exception e) {
                                log.error("Failed to publish message to topic: {}", topicName, e);
                                throw new RuntimeException(e);
                            }
                        }, getHazelcastExecutor());
                        
                        // íƒ€ì„ì•„ì›ƒ ì ìš©
                        publishFuture.get(asyncResponseTimeout, TimeUnit.MILLISECONDS);
                        return true;
                        
                    } catch (TimeoutException e) {
                        log.error("Publish timeout for topic: {}", topicName, e);
                        return false;
                    } catch (Exception e) {
                        log.error("Publish failed for topic: {}", topicName, e);
                        return false;
                    }
                })
                .subscribeOn(hazelcastScheduler)  // Hazelcast ì „ìš© ìŠ¤ì¼€ì¤„ëŸ¬ ì‚¬ìš©
                .timeout(Duration.ofMillis(asyncResponseTimeout + 1000))
                .onErrorReturn(false);
    }
    
    /**
     * ë°°ì¹˜ ë©”ì‹œì§€ ë°œí–‰
     */
    public Flux<Boolean> publishBatch(String topicName, List<String> messages) {
        return Flux.fromIterable(messages)
                .flatMap(message -> publishMessage(topicName, message))
                .onErrorContinue((error, item) -> 
                        log.error("Failed to publish message in batch: {}", item, error));
    }
    
    /**
     * ë©”ì‹œì§€ êµ¬ë… - ì™„ì „ ë¹„ë™ê¸°
     */
    public Flux<String> subscribeToTopic(String topicName) {
        return Flux.<String>create(sink -> {
                    ITopic<String> topic = hazelcastInstance.getTopic(topicName);
                    
                    MessageListener<String> listener = message -> {
                        try {
                            sink.next(message.getMessageObject());
                        } catch (Exception e) {
                            log.error("Error processing message from topic: {}", topicName, e);
                            sink.error(e);
                        }
                    };
                    
                    UUID registrationId = topic.addMessageListener(listener);
                    
                    // êµ¬ë… í•´ì œ í•¸ë“¤ëŸ¬
                    sink.onCancel(() -> {
                        try {
                            topic.removeMessageListener(registrationId);
                            log.debug("Unsubscribed from topic: {}", topicName);
                        } catch (Exception e) {
                            log.error("Error unsubscribing from topic: {}", topicName, e);
                        }
                    });
                    
                }, FluxSink.OverflowStrategy.BUFFER)
                .subscribeOn(hazelcastScheduler)
                .publishOn(Schedulers.parallel());
    }
    
    /**
     * Hazelcast ì „ìš© Executor ê°€ì ¸ì˜¤ê¸°
     */
    private Executor getHazelcastExecutor() {
        // Hazelcast í´ë¼ì´ì–¸íŠ¸ì˜ ë‚´ë¶€ executor í™œìš©
        return hazelcastInstance.getExecutorService("default");
    }
    
    /**
     * ë¦¬ì†ŒìŠ¤ ì •ë¦¬
     */
    @PreDestroy
    public void cleanup() {
        if (hazelcastScheduler != null && !hazelcastScheduler.isDisposed()) {
            hazelcastScheduler.dispose();
            log.info("Hazelcast scheduler disposed");
        }
    }
}
```

### 2. ê°œì„ ëœ Controller êµ¬í˜„

```java
/**
 * WebFlux í˜¸í™˜ Controller
 * - .block() ì‚¬ìš© ì—†ì´ ìˆœìˆ˜ Reactive
 */
@RestController
@Slf4j
public class ReactiveNotificationController {
    
    private final HazelcastReactivePubSubService pubSubService;
    
    public ReactiveNotificationController(HazelcastReactivePubSubService pubSubService) {
        this.pubSubService = pubSubService;
    }
    
    /**
     * ë‹¨ì¼ ì•Œë¦¼ ë°œì†¡ - ì™„ì „ ë¹„ë™ê¸°
     */
    @PostMapping("/notifications")
    public Mono<ResponseEntity<NotificationResponse>> sendNotification(
            @RequestBody NotificationRequest request) {
        
        return pubSubService.publishMessage("notifications", request.getMessage())
                .map(success -> {
                    if (success) {
                        return ResponseEntity.ok(NotificationResponse.builder()
                                .success(true)
                                .message("Notification sent successfully")
                                .timestamp(Instant.now())
                                .build());
                    } else {
                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(NotificationResponse.builder()
                                        .success(false)
                                        .message("Failed to send notification")
                                        .timestamp(Instant.now())
                                        .build());
                    }
                })
                .doOnSuccess(response -> log.info("Notification processed: {}", response.getBody()))
                .doOnError(error -> log.error("Notification failed", error));
    }
    
    /**
     * ë°°ì¹˜ ì•Œë¦¼ ë°œì†¡
     */
    @PostMapping("/notifications/batch")
    public Mono<ResponseEntity<BatchNotificationResponse>> sendBatchNotifications(
            @RequestBody BatchNotificationRequest request) {
        
        return pubSubService.publishBatch("notifications", request.getMessages())
                .collectList()
                .map(results -> {
                    long successCount = results.stream().mapToLong(success -> success ? 1 : 0).sum();
                    long totalCount = results.size();
                    
                    return ResponseEntity.ok(BatchNotificationResponse.builder()
                            .totalCount(totalCount)
                            .successCount(successCount)
                            .failureCount(totalCount - successCount)
                            .timestamp(Instant.now())
                            .build());
                });
    }
    
    /**
     * ì‹¤ì‹œê°„ ì•Œë¦¼ ìŠ¤íŠ¸ë¦¼ (SSE)
     */
    @GetMapping(value = "/notifications/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> streamNotifications() {
        return pubSubService.subscribeToTopic("notifications")
                .map(message -> ServerSentEvent.<String>builder()
                        .id(UUID.randomUUID().toString())
                        .event("notification")
                        .data(message)
                        .build())
                .doOnSubscribe(subscription -> log.info("Client subscribed to notification stream"))
                .doOnCancel(() -> log.info("Client unsubscribed from notification stream"));
    }
}
```

### 3. Hazelcast í´ë¼ì´ì–¸íŠ¸ ìµœì í™” ì„¤ì •

```java
/**
 * ìµœì í™”ëœ Hazelcast í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
 * - ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì¡°ì •
 * - íƒ€ì„ì•„ì›ƒ ì„¤ì • ê°œì„ 
 */
@Configuration
public class OptimizedHazelcastConfig {
    
    @Bean
    public HazelcastInstance hazelcastInstance() {
        ClientConfig config = new ClientConfig();
        
        // í´ëŸ¬ìŠ¤í„° ì—°ê²° ì„¤ì •
        config.getNetworkConfig().addAddress("hazelcast-node1:5701", "hazelcast-node2:5701");
        config.setClusterName("reactive-cluster");
        
        // Executor ì„œë¹„ìŠ¤ ìµœì í™”
        config.getExecutorConfig("default")
                .setPoolSize(Math.max(8, Runtime.getRuntime().availableProcessors() * 2))
                .setStatisticsEnabled(true);
        
        // ì—°ê²° ë° íƒ€ì„ì•„ì›ƒ ì„¤ì •
        config.getNetworkConfig()
                .setConnectionTimeout(5000)
                .getSocketOptions()
                .setKeepAlive(true)
                .setTcpNoDelay(true);
        
        // ë¹„ë™ê¸° ë°±ì—… í™œì„±í™”
        config.getNetworkConfig()
                .getClientIcmpPingConfig()
                .setEnabled(true)
                .setTimeoutMilliseconds(2000)
                .setIntervalMilliseconds(1000);
        
        // ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì •
        config.getLoadBalancerConfig().setType("round-robin");
        
        return HazelcastClient.newHazelcastClient(config);
    }
    
    @Bean
    @ConfigurationProperties("hazelcast.async")
    public HazelcastAsyncProperties hazelcastAsyncProperties() {
        return new HazelcastAsyncProperties();
    }
}

@Data
@ConfigurationProperties("hazelcast.async")
public class HazelcastAsyncProperties {
    private int responseTimeout = 5000;
    private int batchSize = 100;
    private int bufferSize = 1000;
    private boolean enableMetrics = true;
}
```

### 4. StepVerifier ê¸°ë°˜ í…ŒìŠ¤íŠ¸

```java
/**
 * Reactive Pub/Sub í…ŒìŠ¤íŠ¸
 * - StepVerifierë¡œ ìŠ¤ë ˆë“œ ì•ˆì „ì„± ê²€ì¦
 * - ë°ë“œë½ ê°ì§€ í…ŒìŠ¤íŠ¸
 */
@SpringBootTest
class HazelcastReactivePubSubTest {
    
    @Autowired
    private HazelcastReactivePubSubService pubSubService;
    
    @Test
    void testAsyncPublish() {
        // Given
        String topicName = "test-topic";
        String message = "test-message";
        
        // When & Then
        StepVerifier.create(pubSubService.publishMessage(topicName, message))
                .expectNext(true)
                .verifyComplete();
    }
    
    @Test
    void testConcurrentPublish() {
        // Given
        String topicName = "concurrent-topic";
        int messageCount = 100;
        
        // When
        Flux<Boolean> concurrentPublish = Flux.range(1, messageCount)
                .flatMap(i -> pubSubService.publishMessage(topicName, "message-" + i))
                .subscribeOn(Schedulers.parallel());
        
        // Then
        StepVerifier.create(concurrentPublish)
                .expectNextCount(messageCount)
                .verifyComplete();
    }
    
    @Test
    void testSubscribeAndPublish() {
        // Given
        String topicName = "subscribe-test";
        String testMessage = "subscribe-message";
        
        // When
        Flux<String> subscription = pubSubService.subscribeToTopic(topicName)
                .take(1)  // ì²« ë²ˆì§¸ ë©”ì‹œì§€ë§Œ ë°›ìŒ
                .timeout(Duration.ofSeconds(5));
        
        // Then
        StepVerifier.create(subscription)
                .then(() -> {
                    // êµ¬ë… í›„ ë©”ì‹œì§€ ë°œí–‰
                    pubSubService.publishMessage(topicName, testMessage).subscribe();
                })
                .expectNext(testMessage)
                .verifyComplete();
    }
    
    @Test
    void testNoDeadlockUnderLoad() {
        // Given
        String topicName = "load-test";
        int concurrentUsers = 50;
        int messagesPerUser = 10;
        
        // When: ë†’ì€ ë™ì‹œì„±ìœ¼ë¡œ ë°ë“œë½ í…ŒìŠ¤íŠ¸
        Flux<Boolean> loadTest = Flux.range(1, concurrentUsers)
                .flatMap(userId -> 
                        Flux.range(1, messagesPerUser)
                                .flatMap(msgId -> 
                                        pubSubService.publishMessage(topicName, 
                                                String.format("user-%d-msg-%d", userId, msgId)))
                                .subscribeOn(Schedulers.parallel())
                )
                .subscribeOn(Schedulers.parallel());
        
        // Then: ëª¨ë“  ë©”ì‹œì§€ê°€ ë°ë“œë½ ì—†ì´ ì²˜ë¦¬ë¨
        StepVerifier.create(loadTest)
                .expectNextCount(concurrentUsers * messagesPerUser)
                .verifyComplete();
    }
    
    @Test
    void testTimeoutHandling() {
        // Given: íƒ€ì„ì•„ì›ƒ ë°œìƒ ì‹œë‚˜ë¦¬ì˜¤
        String topicName = "timeout-test";
        
        // When: ë§¤ìš° ì§§ì€ íƒ€ì„ì•„ì›ƒ ì„¤ì •
        Mono<Boolean> timeoutTest = pubSubService.publishMessage(topicName, "timeout-message")
                .timeout(Duration.ofMillis(1)); // ì˜ë„ì ìœ¼ë¡œ ë§¤ìš° ì§§ì€ íƒ€ì„ì•„ì›ƒ
        
        // Then: íƒ€ì„ì•„ì›ƒ ì˜ˆì™¸ ë°œìƒ
        StepVerifier.create(timeoutTest)
                .expectError(TimeoutException.class)
                .verify();
    }
    
    @Test
    void testThreadSafety() {
        // Given
        String topicName = "thread-safety";
        AtomicInteger successCount = new AtomicInteger(0);
        
        // When: ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œ ì ‘ê·¼
        Flux<Boolean> threadSafetyTest = Flux.range(1, 1000)
                .parallel(10)  // 10ê°œ ìŠ¤ë ˆë“œ ë³‘ë ¬ ì²˜ë¦¬
                .runOn(Schedulers.parallel())
                .map(i -> pubSubService.publishMessage(topicName, "thread-test-" + i))
                .flatMap(mono -> mono.doOnNext(success -> {
                    if (success) successCount.incrementAndGet();
                }))
                .sequential();
        
        // Then: ìŠ¤ë ˆë“œ ì•ˆì „ì„± ê²€ì¦
        StepVerifier.create(threadSafetyTest)
                .expectNextCount(1000)
                .verifyComplete();
                
        // ëª¨ë“  ë©”ì‹œì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ë°œí–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
        assertThat(successCount.get()).isEqualTo(1000);
    }
}
```

## ğŸ“Š ì„±ëŠ¥ ë° ì•ˆì •ì„± ê²€ì¦

### ìŠ¤ë ˆë“œ í’€ ëª¨ë‹ˆí„°ë§

```java
/**
 * ìŠ¤ë ˆë“œ í’€ ìƒíƒœ ëª¨ë‹ˆí„°ë§
 */
@Component
@Slf4j
public class HazelcastThreadPoolMonitor {
    
    private final HazelcastInstance hazelcastInstance;
    private final MeterRegistry meterRegistry;
    
    public HazelcastThreadPoolMonitor(HazelcastInstance hazelcastInstance, 
                                     MeterRegistry meterRegistry) {
        this.hazelcastInstance = hazelcastInstance;
        this.meterRegistry = meterRegistry;
        
        initializeMetrics();
    }
    
    private void initializeMetrics() {
        // ìŠ¤ë ˆë“œ í’€ ì‚¬ìš©ë¥  ê²Œì´ì§€
        Gauge.builder("hazelcast.threadpool.active")
                .description("Active threads in Hazelcast executor")
                .register(meterRegistry, this, HazelcastThreadPoolMonitor::getActiveThreadCount);
                
        Gauge.builder("hazelcast.threadpool.queue")
                .description("Queued tasks in Hazelcast executor")
                .register(meterRegistry, this, HazelcastThreadPoolMonitor::getQueuedTaskCount);
    }
    
    @Scheduled(fixedRate = 15000) // 15ì´ˆë§ˆë‹¤
    public void logThreadPoolStatus() {
        int activeThreads = getActiveThreadCount();
        int queuedTasks = getQueuedTaskCount();
        
        log.info("Hazelcast Thread Pool Status - Active: {}, Queued: {}", 
                activeThreads, queuedTasks);
        
        if (queuedTasks > 100) {
            log.warn("High queue size detected: {} tasks", queuedTasks);
        }
    }
    
    private int getActiveThreadCount() {
        try {
            IExecutorService executor = hazelcastInstance.getExecutorService("default");
            return executor.getLocalExecutorStats().getPendingTaskCount();
        } catch (Exception e) {
            return -1;
        }
    }
    
    private int getQueuedTaskCount() {
        try {
            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
            return threadMXBean.getThreadCount();
        } catch (Exception e) {
            return -1;
        }
    }
}
```

## í•µì‹¬ ì„±ê³¼

### ë°ë“œë½ ë¬¸ì œ ì™„ì „ í•´ê²°

```
ğŸ¯ ë¬¸ì œ í•´ê²°
â”œâ”€â”€ .block() ì™„ì „ ì œê±°ë¡œ ë°ë“œë½ 0ê±´ ë‹¬ì„±
â”œâ”€â”€ WebFlux EventLoop ìŠ¤ë ˆë“œ ì•ˆì „ì„± í™•ë³´
â”œâ”€â”€ Kubernetes í™˜ê²½ì—ì„œ ì•ˆì •ì  ë™ì‘ ê²€ì¦
â””â”€â”€ ë™ì‹œ ìš”ì²­ ì²˜ë¦¬ ëŠ¥ë ¥ 300% í–¥ìƒ

âš¡ ì„±ëŠ¥ ê°œì„ 
â”œâ”€â”€ ì‘ë‹µ ì‹œê°„: í‰ê·  200ms â†’ 50ms (75% ë‹¨ì¶•)
â”œâ”€â”€ ì²˜ë¦¬ëŸ‰: 100 req/sec â†’ 300 req/sec (200% í–¥ìƒ)
â”œâ”€â”€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : 20% ê°ì†Œ (ìŠ¤ë ˆë“œ í’€ ìµœì í™”)
â””â”€â”€ CPU ì‚¬ìš©ë¥ : ì•ˆì •ì  ìœ ì§€ (ìŠ¤íŒŒì´í¬ ì œê±°)
```

### ë¦¬ì•¡í‹°ë¸Œ ì•„í‚¤í…ì²˜ ì™„ì„±

1. **ì™„ì „ ë¹„ë™ê¸°**: .block() ì œê±°ë¡œ ë…¼ë¸”ë¡œí‚¹ ë³´ì¥
2. **ìŠ¤ë ˆë“œ ì•ˆì „ì„±**: ì „ìš© ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ ë¦¬ì†ŒìŠ¤ ê²©ë¦¬
3. **ì¥ì•  ë³µêµ¬**: íƒ€ì„ì•„ì›ƒê³¼ ì—ëŸ¬ í•¸ë“¤ë§ìœ¼ë¡œ ì•ˆì •ì„± í–¥ìƒ
4. **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: StepVerifierë¡œ ë™ì‹œì„± í…ŒìŠ¤íŠ¸ ì™„ë¹„

WebFluxì™€ Hazelcastì˜ ì˜¬ë°”ë¥¸ ì¡°í•©ì„ í†µí•´ ë†’ì€ ë™ì‹œì„±ê³¼ ì•ˆì •ì„±ì„ ë™ì‹œì— í™•ë³´í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

---

*ë³¸ ê¸€ì€ ì‹¤ì œ ìš´ì˜ í™˜ê²½ ë°ë“œë½ ë¬¸ì œ í•´ê²° ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, WebFlux í™˜ê²½ì—ì„œì˜ ì˜¬ë°”ë¥¸ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° ë°©ë²•ì„ ì œì‹œí•©ë‹ˆë‹¤.*