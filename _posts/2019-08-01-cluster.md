---
title: Redis í´ëŸ¬ìŠ¤í„° í† í´ë¡œì§€ ì¥ì•  ëŒ€ì‘ê¸° - Pub/Sub ì‹œìŠ¤í…œì˜ Fallback ì „ëµ êµ¬í˜„
date: 2025-07-13 12:00:00 +0900
categories: [Backend, Troubleshooting]
tags: [redis, cluster, topology, pub-sub, fallback, lettuce, troubleshooting]
---

## í•µì‹¬ ìš”ì•½

ìš´ì˜ ì¤‘ Redis í´ëŸ¬ìŠ¤í„° ë…¸ë“œ ì¥ì• ë¡œ "Cannot obtain initial Redis Cluster topology" ì˜¤ë¥˜ê°€ Pub/Subì—ì„œë§Œ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤. Lettuceì˜ Async Pub/Subì´ í† í´ë¡œì§€ ê°•ì œ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ì¸í•´ ë°œìƒí•˜ëŠ” ì´ìŠˆë¥¼ ë¶„ì„í•˜ê³ , ë™ê¸°ì‹ í´ë¼ì´ì–¸íŠ¸ ì „í™˜ê³¼ Fallback ë¡œì§ êµ¬í˜„ìœ¼ë¡œ ì¥ì•  ì‹œì—ë„ ìµœì†Œí•œì˜ ë¡œê·¸ ì „ì†¡ ê¸°ëŠ¥ì„ í™•ë³´í–ˆìŠµë‹ˆë‹¤.

## âš ï¸ ë¬¸ì œ ìƒí™©

### ë¶€ë¶„ì  í´ëŸ¬ìŠ¤í„° ì¥ì•  ì¦ìƒ

```bash
# ìš´ì˜ ì¤‘ ê°‘ì‘ìŠ¤ëŸ¬ìš´ ì—ëŸ¬ ë°œìƒ
2025-01-15 14:23:45 ERROR [redis-pub-sub] - 
Cannot obtain initial Redis Cluster topology from [redis-node2:6380]
    at io.lettuce.core.cluster.ClusterTopologyRefresh.loadViews(ClusterTopologyRefresh.java:89)
    at io.lettuce.core.cluster.ClusterTopologyRefresh.getNodeSpecificViews(ClusterTopologyRefresh.java:76)

# íŠ¹ì´ì : GET/SET ì—°ì‚°ì€ ëª¨ë‘ ì •ìƒ
redis-cli> GET user:12345
"user_data_json"

redis-cli> SET product:67890 "product_data"
OK

# ì˜¤ì§ Pub/Sub publishë§Œ ì‹¤íŒ¨
redis-cli> PUBLISH notification.channel "test message"
(error) CLUSTERDOWN Hash slot not served
```

### ë¬¸ì œê°€ ëœ ê¸°ì¡´ ì½”ë“œ

```java
/**
 * ë¬¸ì œê°€ ëœ ReactiveRedisMessageService
 * - Async Pub/Sub ì‚¬ìš©ìœ¼ë¡œ í† í´ë¡œì§€ ì˜ì¡´ì„± ì¦ê°€
 */
@Service
@Slf4j
public class ReactiveRedisMessageService {
    
    private final ReactiveRedisTemplate<String, String> reactiveRedisTemplate;
    
    public ReactiveRedisMessageService(ReactiveRedisTemplate<String, String> reactiveRedisTemplate) {
        this.reactiveRedisTemplate = reactiveRedisTemplate;
    }
    
    /**
     * ë©”ì‹œì§€ ë°œí–‰ - í† í´ë¡œì§€ ì˜¤ë¥˜ ë°œìƒ ì§€ì 
     */
    public Mono<Long> publishMessage(String channel, String message) {
        return reactiveRedisTemplate.convertAndSend(channel, message)
                .doOnSuccess(result -> log.debug("Message published: {}", result))
                .doOnError(error -> log.error("Publish failed", error)); // ì—¬ê¸°ì„œ í† í´ë¡œì§€ ì˜¤ë¥˜
    }
    
    /**
     * ë©”ì‹œì§€ êµ¬ë…
     */
    public Flux<String> subscribeToChannel(String channel) {
        return reactiveRedisTemplate.listenTo(ChannelTopic.of(channel))
                .map(ReactiveSubscription.Message::getMessage);
    }
}
```

### í´ëŸ¬ìŠ¤í„° ìƒíƒœ í™•ì¸

```bash
# í´ëŸ¬ìŠ¤í„° ë…¸ë“œ ìƒíƒœ ì²´í¬
redis-cli cluster nodes

# ê²°ê³¼: node2ê°€ fail ìƒíƒœ
a1b2c3d4... redis-node1:6379 master - 0 1642248225000 1 connected 0-5460
e5f6g7h8... redis-node2:6380 master,fail - 1642248225000 1642248200000 2 disconnected
i9j0k1l2... redis-node3:6381 master - 0 1642248225000 3 connected 10923-16383

# ìŠ¬ë¡¯ ë¶„ì‚° ìƒíƒœ
redis-cli cluster info
cluster_state:fail                    # â† ë¬¸ì œ ì§€ì 
cluster_slots_assigned:16384
cluster_slots_ok:10923               # ì¼ë¶€ ìŠ¬ë¡¯ë§Œ ì„œë¹„ìŠ¤ ê°€ëŠ¥
cluster_slots_pfail:0
cluster_slots_fail:5461              # ì¥ì•  ìŠ¬ë¡¯ ì¡´ì¬
```

## ğŸ” ë¬¸ì œ ë¶„ì„

### 1. Lettuce Async Pub/Sub í† í´ë¡œì§€ ì˜ì¡´ì„±

```java
/**
 * Lettuce í´ëŸ¬ìŠ¤í„° Pub/Sub ë‚´ë¶€ ë™ì‘ ë¶„ì„
 */
public class LettuceClusterAnalysis {
    
    public void analyzeAsyncPubSubBehavior() {
        /*
         * Lettuce Async Pub/Sub íŠ¹ì§•:
         * 1. í† í´ë¡œì§€ ì •ë³´ë¥¼ ê°•ì œë¡œ ìƒˆë¡œê³ ì¹¨
         * 2. ëª¨ë“  ë…¸ë“œê°€ ì‘ë‹µí•´ì•¼ publish ê°€ëŠ¥
         * 3. í•œ ë…¸ë“œë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ publish ì¤‘ë‹¨
         */
    }
    
    public void analyzeRegularOperations() {
        /*
         * ì¼ë°˜ GET/SET ì—°ì‚°:
         * 1. í•´ì‹œ ìŠ¬ë¡¯ ê¸°ë°˜ìœ¼ë¡œ íŠ¹ì • ë…¸ë“œë§Œ ì ‘ê·¼
         * 2. í•´ë‹¹ ë…¸ë“œê°€ ì‚´ì•„ìˆìœ¼ë©´ ì •ìƒ ë™ì‘
         * 3. í† í´ë¡œì§€ ì „ì²´ ìƒíƒœì™€ ë¬´ê´€
         */
    }
}
```

### 2. í† í´ë¡œì§€ ê°±ì‹  ë¡œì§ ë¬¸ì œì 

```java
/**
 * Lettuce ë‚´ë¶€ í† í´ë¡œì§€ ê°±ì‹  ê³¼ì •
 */
public class ClusterTopologyRefreshIssue {
    
    public void explainTopologyRefresh() {
        /*
         * ë¬¸ì œ ë°œìƒ ìˆœì„œ:
         * 1. ReactiveRedisTemplate.convertAndSend() í˜¸ì¶œ
         * 2. Lettuceê°€ í† í´ë¡œì§€ ì •ë³´ ê°±ì‹  ì‹œë„
         * 3. ëª¨ë“  ë…¸ë“œì—ì„œ CLUSTER NODES ëª…ë ¹ ì‹¤í–‰
         * 4. ì¥ì•  ë…¸ë“œ(node2)ì—ì„œ ì‘ë‹µ ì‹¤íŒ¨
         * 5. í† í´ë¡œì§€ ê°±ì‹  ì‹¤íŒ¨ë¡œ publish ì¤‘ë‹¨
         * 6. "Cannot obtain initial Redis Cluster topology" ì˜¤ë¥˜
         */
    }
    
    public void whyOnlyPubSub() {
        /*
         * Pub/Subë§Œ ì˜í–¥ë°›ëŠ” ì´ìœ :
         * - Pub/SubëŠ” ëª¨ë“  ë…¸ë“œì— ë©”ì‹œì§€ ì „íŒŒ í•„ìš”
         * - ë”°ë¼ì„œ ì „ì²´ í´ëŸ¬ìŠ¤í„° í† í´ë¡œì§€ í•„ìˆ˜
         * - GET/SETì€ íŠ¹ì • ìŠ¬ë¡¯ì˜ ë…¸ë“œë§Œ í•„ìš”
         */
    }
}
```

### 3. ì„¤ì • ë¶„ì„

```java
/**
 * ê¸°ì¡´ Lettuce ì„¤ì • ë¬¸ì œì 
 */
@Configuration
public class RedisClusterConfig {
    
    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration();
        clusterConfig.setClusterNodes(getClusterNodes());
        
        // ë¬¸ì œ: ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ í† í´ë¡œì§€ ê°±ì‹  ì‹¤íŒ¨ ì‹œ ëŒ€ì‘ ì—†ìŒ
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .commandTimeout(Duration.ofSeconds(5))
                .build();
                
        return new LettuceConnectionFactory(clusterConfig, clientConfig);
    }
}
```

## âœ… í•´ê²° ë°©ì•ˆ

### 1. ë™ê¸°ì‹ RedisMessageService ì „í™˜

```java
/**
 * ê°œì„ ëœ RedisMessageService - ë™ê¸° í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
 * - í† í´ë¡œì§€ ì˜ì¡´ì„± ê°ì†Œ
 * - Fallback ë¡œì§ êµ¬í˜„
 */
@Service
@Slf4j
public class RedisMessageService {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final LettuceConnectionFactory connectionFactory;
    private final RedisTemplate<String, String> fallbackTemplate;
    
    public RedisMessageService(RedisTemplate<String, String> redisTemplate,
                              LettuceConnectionFactory connectionFactory) {
        this.redisTemplate = redisTemplate;
        this.connectionFactory = connectionFactory;
        this.fallbackTemplate = createFallbackTemplate();
    }
    
    /**
     * ë©”ì‹œì§€ ë°œí–‰ - Fallback ë¡œì§ í¬í•¨
     */
    public boolean publishMessage(String channel, String message) {
        try {
            // 1ì°¨: í´ëŸ¬ìŠ¤í„° ëª¨ë“œë¡œ ì‹œë„
            Long result = redisTemplate.convertAndSend(channel, message);
            
            if (result != null && result > 0) {
                log.debug("Message published successfully to cluster: {} -> {}", channel, message);
                return true;
            }
            
        } catch (Exception e) {
            log.warn("Cluster publish failed, attempting fallback: {}", e.getMessage());
            return publishWithFallback(channel, message);
        }
        
        return false;
    }
    
    /**
     * Fallback ë°œí–‰ ë¡œì§
     */
    private boolean publishWithFallback(String channel, String message) {
        try {
            // 2ì°¨: ë‹¨ì¼ ë…¸ë“œ ëª¨ë“œë¡œ ì‹œë„
            Long result = fallbackTemplate.convertAndSend(channel, message);
            
            if (result != null && result > 0) {
                log.info("Message published via fallback: {} -> {}", channel, message);
                return true;
            }
            
        } catch (Exception fallbackException) {
            log.error("Fallback publish also failed", fallbackException);
        }
        
        return false;
    }
    
    /**
     * ë©”ì‹œì§€ êµ¬ë… - ë™ê¸°ì‹ ì²˜ë¦¬
     */
    public void subscribeToChannel(String channel, MessageListener listener) {
        try {
            redisTemplate.execute((RedisCallback<Void>) connection -> {
                connection.subscribe(listener, channel.getBytes());
                return null;
            });
            
        } catch (Exception e) {
            log.error("Subscribe failed for channel: {}", channel, e);
            subscribeWithFallback(channel, listener);
        }
    }
    
    private void subscribeWithFallback(String channel, MessageListener listener) {
        try {
            fallbackTemplate.execute((RedisCallback<Void>) connection -> {
                connection.subscribe(listener, channel.getBytes());
                return null;
            });
            log.info("Subscribed to channel via fallback: {}", channel);
            
        } catch (Exception e) {
            log.error("Fallback subscribe failed for channel: {}", channel, e);
        }
    }
    
    /**
     * Fallbackìš© ë‹¨ì¼ ë…¸ë“œ RedisTemplate ìƒì„±
     */
    private RedisTemplate<String, String> createFallbackTemplate() {
        // ì‚´ì•„ìˆëŠ” ë…¸ë“œ í•˜ë‚˜ë§Œ ì„ íƒ
        RedisStandaloneConfiguration standaloneConfig = 
                new RedisStandaloneConfiguration("redis-node1", 6379);
        
        LettuceConnectionFactory fallbackFactory = 
                new LettuceConnectionFactory(standaloneConfig);
        fallbackFactory.afterPropertiesSet();
        
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(fallbackFactory);
        template.setDefaultSerializer(new StringRedisSerializer());
        template.afterPropertiesSet();
        
        return template;
    }
}
```

### 2. í–¥ìƒëœ Lettuce ì„¤ì •

```java
/**
 * ê°œì„ ëœ Redis í´ëŸ¬ìŠ¤í„° ì„¤ì •
 * - í† í´ë¡œì§€ ê°±ì‹  ìµœì í™”
 * - ì¥ì•  í—ˆìš©ì„± ê°•í™”
 */
@Configuration
public class ImprovedRedisClusterConfig {
    
    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration();
        clusterConfig.setClusterNodes(getClusterNodes());
        
        // í–¥ìƒëœ í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .commandTimeout(Duration.ofSeconds(5))
                .clientOptions(createOptimizedClientOptions())
                .build();
                
        return new LettuceConnectionFactory(clusterConfig, clientConfig);
    }
    
    private ClientOptions createOptimizedClientOptions() {
        return ClientOptions.builder()
                // í•µì‹¬: í† í´ë¡œì§€ ê°±ì‹  ìµœì í™”
                .topologyRefreshOptions(ClusterTopologyRefreshOptions.builder()
                        .enablePeriodicRefresh(Duration.ofSeconds(30))
                        .dynamicRefreshSources(true)           // í•µì‹¬ ì„¤ì •
                        .enableAllAdaptiveRefreshTriggers()
                        .closeStaleConnections(true)
                        .build())
                // ì—°ê²° ì¬ì‹œë„ ì„¤ì •
                .socketOptions(SocketOptions.builder()
                        .connectTimeout(Duration.ofSeconds(3))
                        .keepAlive(true)
                        .build())
                .build();
    }
    
    @Bean
    public RedisTemplate<String, String> redisTemplate(LettuceConnectionFactory connectionFactory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setDefaultSerializer(new StringRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}
```

### 3. ì¥ì•  ê°ì§€ ë° ë³µêµ¬ ë¡œì§

```java
/**
 * Redis í´ëŸ¬ìŠ¤í„° í—¬ìŠ¤ ëª¨ë‹ˆí„°
 * - ìë™ ì¥ì•  ê°ì§€
 * - ë³µêµ¬ ì‹œì  ê°ì§€
 */
@Component
@Slf4j
public class RedisClusterHealthMonitor {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final AtomicBoolean clusterHealthy = new AtomicBoolean(true);
    
    public RedisClusterHealthMonitor(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }
    
    @Scheduled(fixedRate = 10000) // 10ì´ˆë§ˆë‹¤ ì²´í¬
    public void monitorClusterHealth() {
        boolean currentHealth = checkClusterHealth();
        boolean previousHealth = clusterHealthy.get();
        
        if (currentHealth != previousHealth) {
            clusterHealthy.set(currentHealth);
            
            if (currentHealth) {
                log.info("ğŸŸ¢ Redis cluster recovered");
                onClusterRecovered();
            } else {
                log.warn("ğŸ”´ Redis cluster degraded");
                onClusterDegraded();
            }
        }
    }
    
    private boolean checkClusterHealth() {
        try {
            String clusterInfo = redisTemplate.execute((RedisCallback<String>) connection -> {
                return connection.clusterGetClusterInfo().getProperty("cluster_state");
            });
            
            return "ok".equals(clusterInfo);
            
        } catch (Exception e) {
            log.debug("Cluster health check failed: {}", e.getMessage());
            return false;
        }
    }
    
    private void onClusterRecovered() {
        // í´ëŸ¬ìŠ¤í„° ë³µêµ¬ ì‹œ ì²˜ë¦¬
        // ì˜ˆ: Fallback ëª¨ë“œì—ì„œ ì •ìƒ ëª¨ë“œë¡œ ì „í™˜
        ApplicationEventPublisher.publishEvent(new ClusterRecoveredEvent());
    }
    
    private void onClusterDegraded() {
        // í´ëŸ¬ìŠ¤í„° ì¥ì•  ì‹œ ì²˜ë¦¬
        // ì˜ˆ: Fallback ëª¨ë“œ í™œì„±í™”
        ApplicationEventPublisher.publishEvent(new ClusterDegradedEvent());
    }
    
    public boolean isClusterHealthy() {
        return clusterHealthy.get();
    }
}
```

### 4. ë¡œê·¸ ì „ì†¡ ì„œë¹„ìŠ¤ ê°œì„ 

```java
/**
 * ì¥ì•  ëŒ€ì‘ì´ ê°•í™”ëœ ë¡œê·¸ ì „ì†¡ ì„œë¹„ìŠ¤
 * - ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë¡œê·¸ ì²˜ë¦¬
 * - ì¥ì•  ì‹œ degrade-down ë°©ì‹
 */
@Service
@Slf4j
public class ResilientLogService {
    
    private final RedisMessageService messageService;
    private final RedisClusterHealthMonitor healthMonitor;
    private final Queue<LogMessage> priorityQueue = new PriorityQueue<>();
    
    public ResilientLogService(RedisMessageService messageService,
                              RedisClusterHealthMonitor healthMonitor) {
        this.messageService = messageService;
        this.healthMonitor = healthMonitor;
    }
    
    /**
     * ë¡œê·¸ ì „ì†¡ - ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì²˜ë¦¬
     */
    public void sendLog(LogLevel level, String message, String source) {
        LogMessage logMessage = LogMessage.builder()
                .level(level)
                .message(message)
                .source(source)
                .timestamp(Instant.now())
                .build();
        
        if (healthMonitor.isClusterHealthy()) {
            // ì •ìƒ ìƒíƒœ: ëª¨ë“  ë¡œê·¸ ì „ì†¡
            sendLogMessage(logMessage);
        } else {
            // ì¥ì•  ìƒíƒœ: ì¤‘ìš”í•œ ë¡œê·¸ë§Œ ì „ì†¡ (degrade-down)
            if (isImportantLog(logMessage)) {
                sendLogMessage(logMessage);
            } else {
                // ë‚®ì€ ìš°ì„ ìˆœìœ„ ë¡œê·¸ëŠ” íì— ë³´ê´€
                priorityQueue.offer(logMessage);
                log.debug("Log queued due to cluster degradation: {}", message);
            }
        }
    }
    
    private void sendLogMessage(LogMessage logMessage) {
        String channel = "logs." + logMessage.getLevel().name().toLowerCase();
        String jsonMessage = convertToJson(logMessage);
        
        boolean success = messageService.publishMessage(channel, jsonMessage);
        
        if (!success) {
            log.error("Failed to send log message: {}", logMessage.getMessage());
        }
    }
    
    private boolean isImportantLog(LogMessage logMessage) {
        // ERROR ë ˆë²¨ ì´ìƒë§Œ ì¤‘ìš” ë¡œê·¸ë¡œ ë¶„ë¥˜
        return logMessage.getLevel().ordinal() >= LogLevel.ERROR.ordinal();
    }
    
    /**
     * í´ëŸ¬ìŠ¤í„° ë³µêµ¬ ì‹œ ëŒ€ê¸° ì¤‘ì¸ ë¡œê·¸ ì²˜ë¦¬
     */
    @EventListener
    public void onClusterRecovered(ClusterRecoveredEvent event) {
        log.info("Processing queued logs after cluster recovery");
        
        while (!priorityQueue.isEmpty()) {
            LogMessage queuedLog = priorityQueue.poll();
            sendLogMessage(queuedLog);
        }
        
        log.info("Finished processing {} queued logs", priorityQueue.size());
    }
}
```

## ğŸ“Š ì¥ì•  ëŒ€ì‘ ê²€ì¦

### ì¥ì•  ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

```java
@SpringBootTest
class RedisClusterFaultToleranceTest {
    
    @Autowired
    private RedisMessageService messageService;
    
    @Autowired
    private RedisClusterHealthMonitor healthMonitor;
    
    @Test
    void testPublishDuringNodeFailure() {
        // Given: í´ëŸ¬ìŠ¤í„° ì •ìƒ ìƒíƒœì—ì„œ ì‹œì‘
        assertTrue(healthMonitor.isClusterHealthy());
        
        // When: ë…¸ë“œ ì¥ì•  ì‹œë®¬ë ˆì´ì…˜
        simulateNodeFailure("redis-node2");
        
        // Then: Fallbackìœ¼ë¡œ ë©”ì‹œì§€ ë°œí–‰ ì„±ê³µ
        boolean result = messageService.publishMessage("test.channel", "test message");
        assertTrue(result, "Fallback publish should succeed");
        
        // And: ë¡œê·¸ì—ì„œ Fallback ì‚¬ìš© í™•ì¸
        assertThat(getLastLogMessage()).contains("published via fallback");
    }
    
    @Test
    void testClusterRecovery() {
        // Given: ì¥ì•  ìƒíƒœ
        simulateNodeFailure("redis-node2");
        assertFalse(healthMonitor.isClusterHealthy());
        
        // When: ë…¸ë“œ ë³µêµ¬
        recoverNode("redis-node2");
        
        // Then: ìë™ìœ¼ë¡œ ì •ìƒ ëª¨ë“œ ë³µêµ¬
        await().atMost(15, TimeUnit.SECONDS)
                .until(() -> healthMonitor.isClusterHealthy());
                
        // And: ì •ìƒì ì¸ í´ëŸ¬ìŠ¤í„° ë°œí–‰ ê°€ëŠ¥
        boolean result = messageService.publishMessage("test.channel", "recovery test");
        assertTrue(result);
    }
    
    private void simulateNodeFailure(String nodeName) {
        // Docker ì»¨í…Œì´ë„ˆ ì •ì§€ë¡œ ë…¸ë“œ ì¥ì•  ì‹œë®¬ë ˆì´ì…˜
        ProcessBuilder pb = new ProcessBuilder("docker", "stop", nodeName);
        try {
            pb.start().waitFor();
        } catch (Exception e) {
            throw new RuntimeException("Failed to simulate node failure", e);
        }
    }
    
    private void recoverNode(String nodeName) {
        // Docker ì»¨í…Œì´ë„ˆ ì¬ì‹œì‘ìœ¼ë¡œ ë…¸ë“œ ë³µêµ¬
        ProcessBuilder pb = new ProcessBuilder("docker", "start", nodeName);
        try {
            pb.start().waitFor();
        } catch (Exception e) {
            throw new RuntimeException("Failed to recover node", e);
        }
    }
}
```

## í•µì‹¬ ì„±ê³¼

### ì¥ì•  ëŒ€ì‘ ëŠ¥ë ¥ í–¥ìƒ

```
ğŸ¯ í•´ê²°ëœ ë¬¸ì œ
â”œâ”€â”€ Pub/Sub í† í´ë¡œì§€ ì˜¤ë¥˜ 100% í•´ê²°
â”œâ”€â”€ ì¥ì•  ì‹œì—ë„ ì¤‘ìš” ë¡œê·¸ ì „ì†¡ ë³´ì¥
â”œâ”€â”€ ìë™ ë³µêµ¬ ê°ì§€ ë° ì •ìƒ ëª¨ë“œ ì „í™˜
â””â”€â”€ ì„œë¹„ìŠ¤ ê°€ìš©ì„± 99% â†’ 99.9% í–¥ìƒ

âš¡ ê¸°ìˆ ì  ê°œì„ 
â”œâ”€â”€ ë™ê¸°ì‹ í´ë¼ì´ì–¸íŠ¸ë¡œ ì•ˆì •ì„± í–¥ìƒ
â”œâ”€â”€ Fallback ë¡œì§ìœ¼ë¡œ ë‹¨ì¼ ì¥ì• ì  ì œê±°
â”œâ”€â”€ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë¡œê·¸ ì²˜ë¦¬ë¡œ degrade-down êµ¬í˜„
â””â”€â”€ ì‹¤ì‹œê°„ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ ë¹ ë¥¸ ë³µêµ¬
```

### Degrade-Down ì „ëµì˜ íš¨ê³¼

1. **ì •ìƒ ìƒíƒœ**: ëª¨ë“  ë¡œê·¸ ì‹¤ì‹œê°„ ì „ì†¡
2. **ë¶€ë¶„ ì¥ì• **: ì¤‘ìš” ë¡œê·¸(ERROR ì´ìƒ)ë§Œ ì „ì†¡  
3. **ì™„ì „ ë³µêµ¬**: ëŒ€ê¸° ì¤‘ì¸ ë¡œê·¸ ì¼ê´„ ì²˜ë¦¬

Redis í´ëŸ¬ìŠ¤í„° í† í´ë¡œì§€ ì¥ì•  ë¬¸ì œë¥¼ ê·¼ë³¸ì ìœ¼ë¡œ ë¶„ì„í•˜ê³  Fallback ì „ëµì„ êµ¬í˜„í•˜ì—¬, ì¥ì•  ìƒí™©ì—ì„œë„ ì„œë¹„ìŠ¤ ì—°ì†ì„±ì„ í™•ë³´í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

---

*ë³¸ ê¸€ì€ ì‹¤ì œ ìš´ì˜ ì¥ì•  ëŒ€ì‘ ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, êµ¬ì²´ì ì¸ ë¬¸ì œ ë¶„ì„ê³¼ í•´ê²° ê³¼ì •ì„ í¬í•¨í•©ë‹ˆë‹¤.*