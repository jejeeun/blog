---
title: WAS íŒŒì¼ I/O ë³‘ëª© í•´ê²°ì„ ìœ„í•œ Hazelcast ë¶„ì‚° ë¡œê¹… ì‹œìŠ¤í…œ êµ¬ì¶•ê¸°
description: ì „ì‚¬ í†µí•© ë¡œê·¸ ê´€ë¦¬ì™€ íŒŒì¼ I/O ì„±ëŠ¥ ê°œì„ ì„ ìœ„í•œ ë¶„ì‚° ë¡œê¹… ì•„í‚¤í…ì²˜ ì„¤ê³„ ë° êµ¬í˜„ ê²½í—˜
author: backend-engineer
date: 2024-06-15 14:30:00 +0900
categories: [Backend, Architecture]
tags: [hazelcast, logging, spring-boot, performance, distributed-system]
math: false
mermaid: true
# image:
#   path: /assets/img/hazelcast-logging.png
#   alt: Hazelcast ë¶„ì‚° ë¡œê¹… ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜
---

> **TL;DR**: ë™ê¸° íŒŒì¼ ë¡œê¹…ì˜ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ë³‘ëª©ì„ í•´ê²°í•˜ê¸° ìœ„í•´ AsyncAppenderì™€ Hazelcast ReliableTopicì„ ë¹„êµ ë¶„ì„í•˜ê³ , Redis Pub/Subì˜ ë©”ì‹œì§€ ìœ ì‹¤ ë¬¸ì œì™€ í•´ê²°ì±…ì„ ì‹¤ë¬´ ê´€ì ì—ì„œ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.

---

## ë“¤ì–´ê°€ë©°

ë©€í‹°ëª¨ë“ˆ í™˜ê²½ì—ì„œ ë¡œê¹… ì‹œìŠ¤í…œì„ ì„¤ê³„í•  ë•Œ íŒŒì¼ I/Oë¡œ ì¸í•œ ì„±ëŠ¥ ë³‘ëª©ì€ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ë¬¸ì œ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. íŠ¹íˆ ë†’ì€ íŠ¸ë˜í”½ì´ ì˜ˆìƒë˜ëŠ” ì‹œìŠ¤í…œì—ì„œëŠ” ë¡œê·¸ ì²˜ë¦¬ê°€ ì „ì²´ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ì‚¬ì „ì— ê³ ë ¤í•´ì•¼ í–ˆìŠµë‹ˆë‹¤.

ì—¬ê¸°ì— ë”í•´ ê³ ê°ì‚¬ì—ì„œ **ì¤‘ì•™ì§‘ì¤‘ì‹ ë¡œê·¸ ê´€ë¦¬**ì— ëŒ€í•œ ìš”êµ¬ì‚¬í•­ì´ ì¶”ê°€ë˜ë©´ì„œ ë‹¨ìˆœí•œ ì„±ëŠ¥ ìµœì í™”ë¥¼ ë„˜ì–´ ë¶„ì‚° ë¡œê¹… ì•„í‚¤í…ì²˜ì— ëŒ€í•œ ì „ë©´ì ì¸ ê²€í† ê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.

ê¸°ì¡´ì˜ ê° ì„œë¹„ìŠ¤ë³„ ê°œë³„ íŒŒì¼ ë¡œê¹…ìœ¼ë¡œëŠ” ê³ ê°ì‚¬ì˜ ì¤‘ì•™ì§‘ì¤‘ì‹ ë¡œê·¸ ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•  ìˆ˜ ì—†ì—ˆê³ , ë™ì‹œì— ì„±ëŠ¥ ì €í•˜ ì—†ì´ ì´ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ìƒˆë¡œìš´ ê³¼ì œê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ ê²ªì€ ë¡œê¹… ë³‘ëª© ë¬¸ì œì™€ ê³ ê°ì‚¬ ìš”êµ¬ì‚¬í•­ì„ ëª¨ë‘ ë§Œì¡±ì‹œí‚¤ê¸° ìœ„í•´ ê²€í† í•œ ì—¬ëŸ¬ ì•„í‚¤í…ì²˜ì˜ ì¥ë‹¨ì ì„ ê³µìœ í•˜ê³ ì í•©ë‹ˆë‹¤.

## 1. ë¬¸ì œì˜ ì‹œì‘: ì™œ íŒŒì¼ ë¡œê¹…ì´ ë³‘ëª©ì´ ë ê¹Œ?

### ë™ê¸° íŒŒì¼ I/Oì˜ ìˆ¨ê²¨ì§„ ë¹„ìš©

```java
// ì¼ë°˜ì ì¸ ë™ê¸° ë¡œê¹… - ë¬¸ì œì˜ ì‹œì‘ì 
logger.info("ì‚¬ìš©ì ë¡œê·¸ì¸: userId={}", userId);
// ì´ í•œ ì¤„ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ...
// 1. íŒŒì¼ ì‹œìŠ¤í…œ í˜¸ì¶œ (disk I/O)
// 2. ë””ìŠ¤í¬ ì‘ë‹µ ëŒ€ê¸° (10-50ms blocking)
// 3. ìŠ¤ë ˆë“œ ë¸”ë¡ â†’ OS ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜
// 4. CPU ìºì‹œ ë¬´íš¨í™” ë° TLB flush
```

**ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜(Context Switch)**: ìš´ì˜ì²´ì œê°€ í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ë‚˜ ìŠ¤ë ˆë“œë¥¼ ì¼ì‹œ ì¤‘ë‹¨í•˜ê³  ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œë¡œ CPU ì œì–´ê¶Œì„ ì „í™˜í•˜ëŠ” ê³¼ì •ì…ë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ ë ˆì§€ìŠ¤í„° ìƒíƒœ ì €ì¥/ë³µì›, ë©”ëª¨ë¦¬ ë§µ ë³€ê²½ ë“±ì˜ ì˜¤ë²„í—¤ë“œê°€ ë°œìƒí•©ë‹ˆë‹¤.

ì‹¤ì œ ì„±ëŠ¥ ì¸¡ì • ê²°ê³¼:
- ë™ê¸° ë¡œê¹…: í‰ê·  ì‘ë‹µì‹œê°„ 150ms, TPS 200
- ë¹„ë™ê¸° ë¡œê¹… ì ìš© í›„: í‰ê·  ì‘ë‹µì‹œê°„ 45ms, TPS 800

### ë³‘ëª©ì˜ ê³¼í•™ì  ê·¼ê±°

```
ë””ìŠ¤í¬ I/O ì§€ì—°(10-50ms) â†’ ìŠ¤ë ˆë“œ ë¸”ë¡ â†’ OS ìŠ¤ì¼€ì¤„ëŸ¬ ê°œì… 
â†’ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ â†’ CPU ìºì‹œ ë¯¸ìŠ¤ â†’ ì„±ëŠ¥ ì €í•˜
```

### ë©€í‹°í”„ë¡œì„¸ìŠ¤ vs ë©€í‹°ìŠ¤ë ˆë“œ vs Node.jsì˜ ì ‘ê·¼ ë°©ì‹

**ë©€í‹°ìŠ¤ë ˆë“œ (Java/Spring Boot)**:
- ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê³µìœ 
- ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ë¹„ìš©ì´ ìƒëŒ€ì ìœ¼ë¡œ ë‚®ìŒ (ë©”ëª¨ë¦¬ ë§µ ìœ ì§€)
- í•˜ì§€ë§Œ I/O ë¸”ë¡œí‚¹ ì‹œ ìŠ¤ë ˆë“œ ìˆ˜ë§Œí¼ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ë°œìƒ

**ë©€í‹°í”„ë¡œì„¸ìŠ¤**:
- ê° í”„ë¡œì„¸ìŠ¤ê°€ ë…ë¦½ëœ ë©”ëª¨ë¦¬ ê³µê°„
- ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ë¹„ìš©ì´ ë†’ìŒ (ì „ì²´ ë©”ëª¨ë¦¬ ë§µ êµì²´)
- í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ (IPC) ì˜¤ë²„í—¤ë“œ ì¶”ê°€

**Node.js (ì‹±ê¸€ ìŠ¤ë ˆë“œ + ì´ë²¤íŠ¸ ë£¨í”„)**:
```javascript
// Node.jsëŠ” I/Oë¥¼ ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ ì²˜ë¦¬
fs.writeFile('app.log', logMessage, (err) => {
    if (err) console.error(err);
    // ì½œë°±ì€ ì´ë²¤íŠ¸ ë£¨í”„ì—ì„œ ë¹„ë™ê¸° ì‹¤í–‰
});
// ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ì¦‰ì‹œ ë‹¤ìŒ ì‘ì—… ì§„í–‰
```
- ì‹±ê¸€ ìŠ¤ë ˆë“œë¡œ ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹˜ ìµœì†Œí™”
- í•˜ì§€ë§Œ CPU ì§‘ì•½ì  ì‘ì—…ì—ëŠ” ë¶€ì í•©
- í™•ì¥ì„±ì„ ìœ„í•´ cluster ëª¨ë“ˆë¡œ ë©€í‹°í”„ë¡œì„¸ìŠ¤ í™œìš©

**Java í™˜ê²½ì—ì„œì˜ ë”œë ˆë§ˆ**:
Java/Spring BootëŠ” ë©€í‹°ìŠ¤ë ˆë“œ ê¸°ë°˜ì´ë¯€ë¡œ Node.jsì˜ ì´ë²¤íŠ¸ ë£¨í”„ ë°©ì‹ì„ ì§ì ‘ ì ìš©í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. ëŒ€ì‹  **ë¹„ë™ê¸° í + ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ** íŒ¨í„´ìœ¼ë¡œ ìœ ì‚¬í•œ íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŸ¬í•œ ë³‘ëª©ì€ íŠ¹íˆ ê³ íŠ¸ë˜í”½ í™˜ê²½ì—ì„œ exponentialí•˜ê²Œ ì•…í™”ë©ë‹ˆë‹¤.

## 2. í•´ê²°ì±… íƒìƒ‰: ë¹„ë™ê¸° ë¡œê¹… ì•„í‚¤í…ì²˜ ë¹„êµ

### 2.1 Logback AsyncAppender: JVM ë‚´ë¶€ í ë°©ì‹

**AsyncAppender**: Logbackì—ì„œ ì œê³µí•˜ëŠ” ë¹„ë™ê¸° ë¡œê¹… appenderë¡œ, ë‚´ë¶€ì ìœ¼ë¡œ BlockingQueueë¥¼ ì‚¬ìš©í•˜ì—¬ ë¡œê·¸ ì´ë²¤íŠ¸ë¥¼ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>application.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <queueSize>10000</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <neverBlock>false</neverBlock>
        <appender-ref ref="FILE" />
    </appender>
    
    <root level="INFO">
        <appender-ref ref="ASYNC" />
    </root>
</configuration>
```

**ì¥ì :**
- êµ¬í˜„ ë³µì¡ë„ ë‚®ìŒ
- JVM ë‚´ë¶€ ë©”ëª¨ë¦¬ íë¡œ ì§€ì—°ì‹œê°„ ìµœì†Œ
- Spring Bootì™€ ì™„ë²½ í˜¸í™˜

**ë‹¨ì :**
- ë‹¨ì¼ ë…¸ë“œ ì œí•œ (ëª¨ë“ˆë§ˆë‹¤ ë¡œê·¸ ë¶„ì‚° í•„ìš”)
- JVM ì¬ì‹œì‘ ì‹œ í ë‚´ ë©”ì‹œì§€ ì†ì‹¤ ê°€ëŠ¥
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€

### 2.2 Hazelcast Pub/Sub: ë¶„ì‚° ë©”ì‹œì§• ë°©ì‹

**Hazelcast**: ì¸ë©”ëª¨ë¦¬ ë°ì´í„° ê·¸ë¦¬ë“œ í”Œë«í¼ìœ¼ë¡œ, ë¶„ì‚° ì»´í“¨íŒ…ê³¼ ìºì‹±ì„ ì§€ì›í•©ë‹ˆë‹¤. ReliableTopicì€ ë©”ì‹œì§€ ìœ ì‹¤ì„ ë°©ì§€í•˜ëŠ” pub/sub ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•©ë‹ˆë‹¤.

### ì‹¤ì œ êµ¬í˜„: Logback Custom Appender + Hazelcast í†µí•©

**1. Logback ì„¤ì • (boot-common/logback-spring.xml)**

```xml
<configuration scan="false" scanPeriod="15 seconds">
    <springProperty name="profile" source="spring.profiles.active" defaultValue="default"/>
    <springProperty name="appName" source="spring.application.name" defaultValue="unknown"/>
    
    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <charset>UTF-8</charset>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- Cache Appender - Hazelcastë¡œ ë¶„ì‚° ë¡œê¹… -->
    <appender name="LOG_STASH" class="com.asset.logging.CacheAppender">
        <module>${appName}</module>
        <profile>${profile}</profile>
        <logTopic>${log.topic-name:-LOG}</logTopic>
    </appender>
    
    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="LOG_STASH" />
        </root>
    </springProfile>
</configuration>
```

**2. Custom CacheAppender êµ¬í˜„**

```java
@Slf4j
public class CacheAppender extends AppenderBase<ILoggingEvent> {

    private static final ObjectMapper objectMapper = new ObjectMapper();
    private CacheProxy<String, String> cacheProxy;
    private String module;
    private String profile;
    private String logTopic;
    private boolean isInitialized = false;

    // ì„±ëŠ¥ ìµœì í™”: ThreadLocalë¡œ Map ì¬ì‚¬ìš©
    private static final ThreadLocal<Map<String, Object>> threadLocalLogMap = 
        ThreadLocal.withInitial(ConcurrentHashMap::new);

    // Logback XMLì—ì„œ ë™ì  ì£¼ì…
    public void setModule(String module) { this.module = module; }
    public void setProfile(String profile) { this.profile = profile; }
    public void setLogTopic(String logTopic) { this.logTopic = logTopic; }
    
    public void setCacheProxy(CacheProxy<String, String> cacheProxy) {
        this.cacheProxy = cacheProxy;
        this.isInitialized = true;
    }

    @Override
    protected void append(ILoggingEvent event) {
        if (!isInitialized) return;

        try {
            Map<String, Object> logEntry = threadLocalLogMap.get();
            logEntry.clear();

            logEntry.put("timestamp", event.getTimeStamp());
            logEntry.put("level", event.getLevel().toString());
            logEntry.put("thread", event.getThreadName());
            logEntry.put("logger", event.getLoggerName());
            logEntry.put("message", event.getFormattedMessage());
            logEntry.put("profile", profile);
            logEntry.put("module", module);

            String jsonLog = objectMapper.writeValueAsString(logEntry);
            cacheProxy.publishJsonString(logTopic, jsonLog);

        } catch (Exception e) {
            // StackOverflow ë°©ì§€ë¥¼ ìœ„í•´ System.err ì‚¬ìš©
            System.err.println("[CacheAppender] ë¡œê·¸ ì „ì†¡ ì‹¤íŒ¨: " + e.getMessage());
        }
    }
}
```

**3. Hazelcast ë©”ì‹œì§€ ì„œë¹„ìŠ¤ êµ¬í˜„**

```java
@Service
@Conditional(HazelcastPubSubCondition.class)
public class HazelcastMessageService<T extends Serializable> implements CacheMessageService<T> {

    private static final ObjectMapper objectMapper = new ObjectMapper();
    private final HazelcastInstance hazelcastInstance;
    private final HazelcastConfigManager<T> ringBufferManager;
    private final ConcurrentHashMap<String, UUID> listenerMap = new ConcurrentHashMap<>();

    @Override
    public void publish(String channel, T message) {
        // ë°œì†¡ì ì •ë³´ í¬í•¨í•œ MessageWrapper ìƒì„±
        String senderId = hazelcastInstance.getCluster().getLocalMember().getUuid().toString();
        MessageWrapper<T> wrapped = new MessageWrapper<>(senderId, message);

        // 1. ì‹¤ì‹œê°„ ì „ì†¡ (ITopic)
        ITopic<MessageWrapper<T>> topic = hazelcastInstance.getTopic(channel);
        topic.publish(wrapped);

        // 2. Ringbuffer ì €ì¥ (ê³¼ê±° ë©”ì‹œì§€ ì¬ìƒìš©)
        Ringbuffer<MessageWrapper<T>> ringbuffer = 
            ringBufferManager.getRingbuffer(channel + "-ringbuffer");
        ringbuffer.addAsync(wrapped, OverflowPolicy.OVERWRITE);
    }

    @Override
    public void subscribe(String channel, CacheMessageAdapter<T> delegate) {
        // 1. ê³¼ê±° ë©”ì‹œì§€ ì¬ìƒ (Ringbufferì—ì„œ)
        replayFromRingbuffer(channel, delegate);

        // 2. ì‹¤ì‹œê°„ ìˆ˜ì‹  ì„¤ì •
        String localMemberId = hazelcastInstance.getCluster().getLocalMember().getUuid().toString();
        ITopic<MessageWrapper<T>> topic = hazelcastInstance.getTopic(channel);
        
        // ìê¸° ë©”ì‹œì§€ í•„í„°ë§í•˜ëŠ” ë˜í•‘ëœ delegate
        CacheMessageAdapter<MessageWrapper<T>> wrappedDelegate = wrapper -> {
            if (!localMemberId.equals(wrapper.getSenderId())) {
                delegate.handleMessage(wrapper.getPayload());
            }
        };

        UUID listenerId = topic.addMessageListener(
            new HazelcastMessageListener<>(ringBufferManager, channel, wrappedDelegate, localMemberId)
        );
        
        listenerMap.put(channel, listenerId);
    }

    @Override
    public void publishJsonString(String channel, T message) {
        try {
            String senderId = hazelcastInstance.getCluster().getLocalMember().getUuid().toString();

            Map<String, Object> jsonPayload = Map.of(
                "senderId", senderId,
                "timestamp", System.currentTimeMillis(),
                "payload", message
            );

            String json = objectMapper.writeValueAsString(jsonPayload);
            ITopic<String> topic = hazelcastInstance.getTopic(channel);
            topic.publish(json);

        } catch (JsonProcessingException e) {
            log.warn("JSON ì§ë ¬í™” ì‹¤íŒ¨", e);
        }
    }

    private void replayFromRingbuffer(String channel, CacheMessageAdapter<T> delegate) {
        Ringbuffer<MessageWrapper<T>> ringbuffer = 
            ringBufferManager.getRingbuffer(channel + "-ringbuffer");

        try {
            long head = ringbuffer.headSequence();
            long tail = ringbuffer.tailSequence();
            long fromSequence = Math.max(tail - 100, head); // ìµœê·¼ 100ê°œ
            String localMemberId = hazelcastInstance.getCluster().getLocalMember().getUuid().toString();

            ringbuffer.readManyAsync(fromSequence, 1, 100, null)
                .whenComplete((resultSet, throwable) -> {
                    if (throwable != null) {
                        log.warn("Ringbuffer read ì‹¤íŒ¨ [{}]", channel, throwable);
                        return;
                    }

                    resultSet.forEach(msg -> {
                        if (!localMemberId.equals(msg.getSenderId())) {
                            delegate.handleMessage(msg.getPayload());
                        }
                    });
                });
        } catch (Exception e) {
            log.warn("Ringbuffer ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ [{}]", channel, e);
        }
    }

    @Override
    public void unsubscribe(String channel) {
        UUID listenerId = listenerMap.remove(channel);
        if (listenerId != null) {
            ITopic<MessageWrapper<T>> topic = hazelcastInstance.getTopic(channel);
            topic.removeMessageListener(listenerId);
        }
    }
}
```

**4. ë©€í‹°ëª¨ë“ˆ ì•„í‚¤í…ì²˜ì™€ í†µí•©**

```
platform-backend/
â”œâ”€â”€ boot-common/                    # ê³µí†µ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ logback-spring.xml         # í†µí•© ë¡œê¹… ì„¤ì •
â”‚   â””â”€â”€ CacheAppender.java         # ì»¤ìŠ¤í…€ Appender
â”œâ”€â”€ admin-service/                 # ê° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤
â”œâ”€â”€ authorization-service/
â”œâ”€â”€ gateway-service/
â””â”€â”€ cache-reactive-service/        # ë¡œê·¸ ìˆ˜ì§‘ ì„œë¹„ìŠ¤
```

ëª¨ë“  ì„œë¹„ìŠ¤ê°€ `boot-common`ì„ ì˜ì¡´í•˜ë¯€ë¡œ **ì¼ê´€ëœ ë¡œê¹… ì •ì±…**ì´ ìë™ ì ìš©ë©ë‹ˆë‹¤. ê° ì„œë¹„ìŠ¤ì˜ ë¡œê·¸ê°€ ìë™ìœ¼ë¡œ ì¤‘ì•™ì§‘ì¤‘ì‹ìœ¼ë¡œ ìˆ˜ì§‘ë˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.

### 2.3 Redis Pub/Subì˜ í•¨ì •ê³¼ ëŒ€ì•ˆ

ì²˜ìŒì—ëŠ” Redis Pub/Subì„ ê³ ë ¤í–ˆì§€ë§Œ, ì¹˜ëª…ì ì¸ í•œê³„ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.

```bash
# Redis Pub/Sub - ë©”ì‹œì§€ ìœ ì‹¤ ì‹œë‚˜ë¦¬ì˜¤
127.0.0.1:6379> PUBLISH logs "ì¤‘ìš”í•œ ë¡œê·¸ ë©”ì‹œì§€"
(integer) 0  # êµ¬ë…ìê°€ ì—†ì–´ì„œ ë©”ì‹œì§€ ì†Œë©¸!

# ë„¤íŠ¸ì›Œí¬ íŒŒí‹°ì…˜ ë°œìƒ ì‹œ
# êµ¬ë… ì—°ê²°ì´ ëŠì–´ì§€ë©´ ê·¸ ìˆœê°„ì˜ ëª¨ë“  ë©”ì‹œì§€ ìœ ì‹¤
```

**Redis Pub/Sub ìœ ì‹¤ ì›ì¸:**
- ë©”ì‹œì§€ê°€ ë©”ëª¨ë¦¬ì—ë§Œ ì¡´ì¬ (ì˜ì†ì„± ì—†ìŒ)
- êµ¬ë…ìê°€ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì†Œë©¸
- `noeviction` ì •ì±…ì€ key evictionì—ë§Œ ì ìš©ë˜ì–´ pub/sub ë©”ì‹œì§€ì—ëŠ” ë¬´ê´€

**ëŒ€ì•ˆ: Redis Streams**

```bash
# Redis Streams - ì˜ì†ì„±ê³¼ ì¬ì²˜ë¦¬ ë³´ì¥
127.0.0.1:6379> XADD app-logs * level INFO msg "ì‚¬ìš©ì ë¡œê·¸ì¸" service "user-api"
"1721808000000-0"

# Consumer Groupìœ¼ë¡œ at-least-once ë³´ì¥
127.0.0.1:6379> XREADGROUP GROUP log-processors consumer1 STREAMS app-logs >
```

```java
@Service
public class RedisStreamsLogPublisher {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private static final String STREAM_KEY = "app-logs";
    
    public void publishLog(LogMessage logMessage) {
        Map<String, Object> fields = Map.of(
            "timestamp", logMessage.getTimestamp(),
            "level", logMessage.getLevel(),
            "message", logMessage.getMessage(),
            "service", logMessage.getServiceName()
        );
        
        redisTemplate.opsForStream()
            .add(STREAM_KEY, fields);
    }
}
```

## 3. ë¡œê·¸ êµ¬ë…ì(log-subscriber) ì•„í‚¤í…ì²˜

ì‹¤ì œ ì¤‘ì•™ì§‘ì¤‘ì‹ ë¡œê¹…ì˜ í•µì‹¬ì€ **êµ¬ë…ì ì‹œìŠ¤í…œ**ì…ë‹ˆë‹¤. ëª¨ë“  ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ì—ì„œ ë°œì†¡ëœ ë¡œê·¸ë¥¼ ìˆ˜ì‹ í•˜ì—¬ ì ì ˆíˆ ì²˜ë¦¬í•˜ëŠ” ë…ë¦½ì ì¸ ì„œë¹„ìŠ¤ë¥¼ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

### 3.1 ë©”ì¸ êµ¬ë…ì ì„¤ì •

```java
@Component
@RequiredArgsConstructor
public class LogSubscriber {

    private final CachePubSubFactory factory;
    private final CacheMessageAdapter<String> logHandler;

    @Value("${log.topic-name:LOG}")
    private String logTopic;

    @PostConstruct
    public void subscribe() {
        CacheMessageService<String> service = factory.createPubSubService(String.class);
        service.subscribe(logTopic, logHandler);
        log.info("LogSubscriber: '{}' ì±„ë„ êµ¬ë… ì‹œì‘", logTopic);
    }
}
```

### 3.2 ë¡œê·¸ ë ˆë²¨ë³„ ë¶„ì‚° ì²˜ë¦¬: LogDispatcher

**ë¬¸ì œ**: ëª¨ë“  ë¡œê·¸ë¥¼ ë‹¨ì¼ ìŠ¤ë ˆë“œë¡œ ì²˜ë¦¬í•˜ë©´ ERROR ë¡œê·¸ê°€ INFO ë¡œê·¸ì— ë°€ë ¤ ì§€ì—°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**í•´ê²°**: ë¡œê·¸ ë ˆë²¨ë³„ë¡œ íë¥¼ ë¶„ë¦¬í•˜ì—¬ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬ë¥¼ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

```java
@Component
@RequiredArgsConstructor
public class LogDispatcher {

    private final LogFileAdapter logFileAdapter;

    // ë¡œê·¸ ë ˆë²¨ë³„ í í¬ê¸° ìµœì í™”
    private final Map<String, BlockingQueue<String>> levelQueues = Map.of(
            "ERROR", new ArrayBlockingQueue<>(4096),  // ì—ëŸ¬ëŠ” í° ë²„í¼
            "WARN", new ArrayBlockingQueue<>(2048),   // ì›Œë‹ì€ ì¤‘ê°„
            "INFO", new ArrayBlockingQueue<>(4096),   // ì •ë³´ì„± ë¡œê·¸
            "DEBUG", new ArrayBlockingQueue<>(8192)   // ë””ë²„ê·¸ëŠ” ê°€ì¥ ë§ìŒ
    );

    private final List<Thread> workerThreads = new ArrayList<>();

    @PostConstruct
    public void startWorkers() {
        levelQueues.forEach((level, queue) -> {
            Thread worker = new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        String msg = queue.take(); // Blocking
                        logFileAdapter.handleMessage(msg);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    } catch (Exception ex) {
                        log.error("ë¡œê·¸ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ (level: {})", level, ex);
                    }
                }
            });
            worker.setName("log-worker-" + level);
            worker.setDaemon(true);
            worker.start();
            workerThreads.add(worker);
        });
        log.info("LogDispatcher: {} worker threads started", workerThreads.size());
    }

    @PreDestroy
    public void shutdown() {
        log.info("LogDispatcher: Initiating graceful shutdown...");
        workerThreads.forEach(Thread::interrupt);
        // ìµœëŒ€ 1ì´ˆ ëŒ€ê¸° í›„ ê°•ì œ ì¢…ë£Œ
        workerThreads.forEach(worker -> {
            try { worker.join(1000); } 
            catch (InterruptedException e) { Thread.currentThread().interrupt(); }
        });
    }
}
```

### 3.3 ë™ì  ë¡œê·¸ íŒŒì¼ ìƒì„±: LogFileAdapter

**í•µì‹¬ ì•„ì´ë””ì–´**: ê° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ì˜ profile/module/levelì— ë”°ë¼ **ë™ì ìœ¼ë¡œ ë¡œê±°ë¥¼ ìƒì„±**í•˜ì—¬ íŒŒì¼ì„ ë¶„ë¦¬í•©ë‹ˆë‹¤.

```java
@Component
@RequiredArgsConstructor
public class LogFileAdapter implements CacheMessageAdapter<String> {
    
    private static final DateTimeFormatter formatter = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final ObjectMapper objectMapper = new ObjectMapper();
    
    // ë™ì  ìƒì„±ëœ Logger ìºì‹±
    private final Map<String, Logger> loggerCache = new ConcurrentHashMap<>();

    @Value("${log.file.max-history:7}")
    private int maxHistory;

    @Value("${log.file.base-path:../../logs/}")
    private String baseLogPath;

    @Override
    public void handleMessage(String message) {
        try {
            Map<String, Object> logMap = objectMapper.readValue(message, Map.class);

            String profile = (String) logMap.getOrDefault("profile", "default");
            String module = (String) logMap.getOrDefault("module", "unknown");
            String level = ((String) logMap.getOrDefault("level", "INFO")).toUpperCase();
            Long timestamp = ((Number) logMap.get("timestamp")).longValue();
            String thread = (String) logMap.getOrDefault("thread", "main");
            String loggerName = (String) logMap.getOrDefault("logger", "anonymous");
            String logMessage = (String) logMap.getOrDefault("message", "");

            String formattedTime = formatter.format(
                Instant.ofEpochMilli(timestamp).atZone(ZoneId.of("Asia/Seoul"))
            );

            // í†µí•© ë¡œê·¸ í¬ë§·
            String formattedLog = String.format(
                "[%s] [%s] [%s] [%s] [%s] [%s] - %s",
                profile, module, formattedTime, level, thread, loggerName, logMessage
            );

            Logger moduleLogger = getOrCreateLogger(profile, module, level);

            // ë¡œê·¸ ë ˆë²¨ì— ë”°ë¥¸ ì ì ˆí•œ ë©”ì„œë“œ í˜¸ì¶œ
            switch (level) {
                case "ERROR" -> moduleLogger.error(formattedLog);
                case "WARN" -> moduleLogger.warn(formattedLog);
                case "DEBUG" -> moduleLogger.debug(formattedLog);
                default -> moduleLogger.info(formattedLog);
            }

        } catch (Exception e) {
            log.warn("ë¡œê·¸ íŒŒì‹± ì‹¤íŒ¨: {}", message, e);
        }
    }

    /**
     * ë™ì  Logger ìƒì„± ë¡œì§
     * ê²½ë¡œ: ../../logs/{module}/{profile}/{yyyy/MMdd}/{Level}_yyyyMMdd.log.gz
     */
    private Logger getOrCreateLogger(String profile, String module, String level) {
        String loggerName = "module." + module + "." + profile + "." + level;
        
        return loggerCache.computeIfAbsent(loggerName, name -> {
            LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();
            Logger logger = context.getLogger(name);

            // íŒŒì¼ ê²½ë¡œ ë™ì  ìƒì„±
            String basePath = baseLogPath + module + "/" + profile + "/";
            String fileNamePattern = basePath + "%d{yyyy/MMdd}/" + 
                level.substring(0,1).toUpperCase() + level.substring(1).toLowerCase() + 
                "_%d{yyyyMMdd}.log.gz";

            // RollingFileAppender ì„¤ì •
            RollingFileAppender fileAppender = new RollingFileAppender();
            fileAppender.setContext(context);
            fileAppender.setName("FILE-" + module + "-" + profile + "-" + level);

            TimeBasedRollingPolicy rollingPolicy = new TimeBasedRollingPolicy();
            rollingPolicy.setContext(context);
            rollingPolicy.setParent(fileAppender);
            rollingPolicy.setFileNamePattern(fileNamePattern);
            rollingPolicy.setMaxHistory(maxHistory); // 7ì¼ ë³´ê´€
            fileAppender.setRollingPolicy(rollingPolicy);
            rollingPolicy.start();

            PatternLayoutEncoder encoder = new PatternLayoutEncoder();
            encoder.setContext(context);
            encoder.setPattern("%msg%n"); // ì´ë¯¸ í¬ë§·ëœ ë©”ì‹œì§€ ê·¸ëŒ€ë¡œ ì¶œë ¥
            encoder.start();

            fileAppender.setEncoder(encoder);
            fileAppender.start();

            // AsyncAppenderë¡œ ë…¼ë¸”ë¡œí‚¹ ì²˜ë¦¬
            AsyncAppender asyncAppender = new AsyncAppender();
            asyncAppender.setContext(context);
            asyncAppender.setName("ASYNC-" + module + "-" + profile + "-" + level);
            asyncAppender.setQueueSize(16384);
            asyncAppender.setDiscardingThreshold(90); // 90% ì°° ë•Œê¹Œì§€ ë²„í¼ë§
            asyncAppender.addAppender(fileAppender);
            asyncAppender.start();

            logger.setAdditive(false); // ë¶€ëª¨ Loggerë¡œ ì „íŒŒ ë°©ì§€
            logger.addAppender(asyncAppender);

            return logger;
        });
    }
}
```

### 3.4 Hazelcast ë©”ì‹œì§€ ë¦¬ìŠ¤ë„ˆì™€ ì‹¤íŒ¨ ë³µêµ¬

```java
@RequiredArgsConstructor
public class HazelcastMessageListener<T> implements MessageListener<T> {

    private final HazelcastConfigManager<T> ringbufferConfigManager;
    private final String topicName;
    private final CacheMessageAdapter<T> delegate;
    private final String localMemberId;
    
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

    @Override
    public void onMessage(Message<T> message) {
        T payload = message.getMessageObject();

        try {
            delegate.handleMessage(payload); // ì •ìƒ ì²˜ë¦¬
        } catch (Exception e) {
            log.warn("ë©”ì‹œì§€ ì²˜ë¦¬ ì‹¤íŒ¨ [{}]: {}", topicName, e.getMessage());
            
            // ì‹¤íŒ¨í•œ ë©”ì‹œì§€ë¥¼ RingBufferì— ì €ì¥í•˜ê³  ì¬ì‹œë„ ìŠ¤ì¼€ì¤„ë§
            String ringBufferName = topicName + "-ringbuffer";
            Ringbuffer<T> ringbuffer = ringbufferConfigManager.getRingbuffer(ringBufferName);
            
            ringbuffer.addAsync(payload, OverflowPolicy.OVERWRITE)
                .thenAccept(seq -> {
                    log.info("ì‹¤íŒ¨ ë©”ì‹œì§€ RingBuffer ì €ì¥ [{}], seq={}", topicName, seq);
                    scheduleRetry(ringbuffer, seq, topicName, 30L); // 30ì´ˆ í›„ ì¬ì‹œë„
                });
        }
    }

    private void scheduleRetry(Ringbuffer<T> ringbuffer, long sequence, String topicName, long retryPeriod) {
        scheduler.scheduleAtFixedRate(() -> {
            try {
                T payload;
                try {
                    payload = ringbuffer.readOne(sequence);
                } catch (StaleSequenceException stale) {
                    // Sequenceê°€ ë„ˆë¬´ ì˜¤ë˜ë˜ì–´ RingBufferì—ì„œ ì‚¬ë¼ì§„ ê²½ìš°
                    long safeSeq = ringbuffer.headSequence();
                    log.warn("Stale sequence [{}], ìµœì‹  ìœ„ì¹˜ë¡œ ì¬ì„¤ì • [{}]", sequence, safeSeq);
                    payload = ringbuffer.readOne(safeSeq);
                }

                delegate.handleMessage(payload);
                log.info("ì¬ì‹œë„ ì„±ê³µ [{}]: {}", topicName, payload);
                throw new CancellationException(); // ì„±ê³µ ì‹œ ì¬ì‹œë„ ì¤‘ë‹¨

            } catch (CancellationException stop) {
                throw stop; // ì •ìƒ ì¢…ë£Œ
            } catch (ClassCastException castEx) {
                log.error("íƒ€ì… ë¶ˆì¼ì¹˜ë¡œ ì¬ì‹œë„ ì¤‘ë‹¨ [{}]: {}", topicName, castEx.getMessage());
                throw new CancellationException();
            } catch (Exception e) {
                log.warn("ì¬ì‹œë„ ì‹¤íŒ¨ [{}]: {}", topicName, e.getMessage());
                // ê³„ì† ì¬ì‹œë„
            }
        }, 0, retryPeriod, TimeUnit.SECONDS);
    }
}
```

### 3.5 ìµœì¢… ë¡œê·¸ íŒŒì¼ êµ¬ì¡°

êµ¬ë…ìë¥¼ í†µí•´ ìƒì„±ë˜ëŠ” ë¡œê·¸ íŒŒì¼ êµ¬ì¡°ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```
logs/
â”œâ”€â”€ admin-service/
â”‚   â”œâ”€â”€ prod/
â”‚   â”‚   â””â”€â”€ 2025/0714/
â”‚   â”‚       â”œâ”€â”€ Error_20250714.log.gz
â”‚   â”‚       â”œâ”€â”€ Warn_20250714.log.gz
â”‚   â”‚       â””â”€â”€ Info_20250714.log.gz
â”‚   â””â”€â”€ dev/
â”œâ”€â”€ gateway-service/
â”‚   â”œâ”€â”€ prod/
â”‚   â””â”€â”€ dev/
â””â”€â”€ authorization-service/
    â”œâ”€â”€ prod/
    â””â”€â”€ dev/
```

ê° ë¡œê·¸ íŒŒì¼ì˜ ë‚´ìš©:
```
[prod] [admin-service] [2025-07-14 15:30:25] [INFO] [http-nio-8080-exec-1] [com.asset.admin.UserController] - ì‚¬ìš©ì ë¡œê·¸ì¸ ì„±ê³µ: userId=12345
[prod] [admin-service] [2025-07-14 15:30:26] [ERROR] [http-nio-8080-exec-2] [com.asset.admin.OrderService] - ì£¼ë¬¸ ì²˜ë¦¬ ì‹¤íŒ¨: orderId=67890
```

## 4. ì•„í‚¤í…ì²˜ ì„ íƒ ê¸°ì¤€ê³¼ ì‹¤ë¬´ ì ìš©

### ìš°ë¦¬ íŒ€ì˜ ìµœì¢… ì„ íƒ: í•˜ì´ë¸Œë¦¬ë“œ ì•„í‚¤í…ì²˜

**ì„ íƒ ì´ìœ **: ê³ ê°ì‚¬ì˜ ì¤‘ì•™ì§‘ì¤‘ì‹ ë¡œê·¸ ìš”êµ¬ì‚¬í•­ + ì„±ëŠ¥ ìµœì í™” + ìš´ì˜ í˜„ì‹¤ì„±ì˜ ê· í˜•

### ì‹¤ì œ ìš´ì˜ ì§€í‘œ

**ì ìš© ì „ (ê° ì„œë¹„ìŠ¤ë³„ íŒŒì¼ ë¡œê¹…)**
```
- ë¡œê·¸ íŒŒì¼: 12ê°œ ì„œë¹„ìŠ¤ Ã— 3ê°œ í™˜ê²½ = 36ê°œ ë””ë ‰í† ë¦¬
- ë¡œê·¸ ê²€ìƒ‰: SSH + grep ì¡°í•©ìœ¼ë¡œ ìˆ˜ë™ ê²€ìƒ‰
- ì¥ì•  ì¶”ì : í‰ê·  15ë¶„ (ì—¬ëŸ¬ ì„œë¹„ìŠ¤ ë¡œê·¸ ìˆ˜ì§‘ ì‹œê°„)
- ìŠ¤í† ë¦¬ì§€: ê° ì„œë²„ë³„ ë¡œì»¬ ë””ìŠ¤í¬ (ë°±ì—… ëˆ„ë½ ìœ„í—˜)
```

**ì ìš© í›„ (Hazelcast + log-subscriber)**
```
- ë¡œê·¸ íŒŒì¼: ì²´ê³„ì  êµ¬ì¡° (../../logs/{module}/{profile}/{date}/{level}.log.gz)
- ë¡œê·¸ ê²€ìƒ‰: ì¤‘ì•™ ì„œë²„ì—ì„œ í†µí•© ê²€ìƒ‰ ê°€ëŠ¥
- ì¥ì•  ì¶”ì : í‰ê·  3ë¶„ (ë‹¨ì¼ ìœ„ì¹˜ì—ì„œ ëª¨ë“  ë¡œê·¸ ì¡°íšŒ)
- ìŠ¤í† ë¦¬ì§€: ì¤‘ì•™ì§‘ì¤‘ + ìë™ ì••ì¶• (7ì¼ ìˆœí™˜ ë³´ê´€)
```

## 5. ì„±ëŠ¥ ì˜í–¥ê³¼ ìš´ì˜ ê²½í—˜

### ì²´ê° ì„±ëŠ¥ ê°œì„ 

ì‹¤ì œ ìš´ì˜ì—ì„œ ëŠë‚€ ê°œì„  íš¨ê³¼:

```
ê¸°ì¡´ (ë™ê¸° íŒŒì¼ ë¡œê¹…):
- ë¡œê·¸ ë§ì€ API í˜¸ì¶œ ì‹œ ëˆˆì— ë„ëŠ” ì§€ì—°
- CPU ì‚¬ìš©ë¥ ì´ ë†’ì„ ë•Œ ì‘ë‹µ ì†ë„ ì €í•˜ ì²´ê°

ì ìš© í›„ (ë¹„ë™ê¸° + ë¶„ì‚° ë¡œê¹…):
- API ì‘ë‹µ ì†ë„ ì²´ê°ìƒ ê°œì„ 
- ë¡œê·¸ëŸ‰ì´ ë§ì•„ì ¸ë„ ì„œë¹„ìŠ¤ ì„±ëŠ¥ì— ì˜í–¥ ì—†ìŒ
- ë¶„ì‚° ë¡œê¹… ì¶”ê°€ë¡œ ì•½ê°„ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€ (í—ˆìš© ë²”ìœ„)
```

### ì‹¤ì œ ìš´ì˜ì—ì„œ ì¤‘ìš”í–ˆë˜ ê²ƒë“¤

**1. ë¡œê·¸ ë ˆë²¨ë³„ ì²˜ë¦¬ ìš°ì„ ìˆœìœ„**
```java
// ERROR ë¡œê·¸ê°€ INFO/DEBUGì— ë°€ë¦¬ì§€ ì•Šë„ë¡ í ë¶„ë¦¬
private final Map<String, BlockingQueue<String>> levelQueues = Map.of(
    "ERROR", new ArrayBlockingQueue<>(4096),  // ì—ëŸ¬ëŠ” ì¶©ë¶„í•œ ë²„í¼
    "WARN", new ArrayBlockingQueue<>(2048),   
    "INFO", new ArrayBlockingQueue<>(4096),   
    "DEBUG", new ArrayBlockingQueue<>(8192)   // ë””ë²„ê·¸ëŠ” ê°€ì¥ ë§ìŒ
);
```
ì‹¤ì œë¡œ ERROR ë¡œê·¸ê°€ DEBUG ë¡œê·¸ì— ë°€ë ¤ì„œ ëŠ¦ê²Œ ì²˜ë¦¬ë˜ëŠ” ê²ƒì„ ë°©ì§€í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

**2. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê´€ë¦¬**
```java
// Logger ë¬´ì œí•œ ìƒì„± ë°©ì§€
private final Map<String, Logger> loggerCache = 
    Collections.synchronizedMap(new LinkedHashMap<String, Logger>(100, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, Logger> eldest) {
            return size() > 100; // 100ê°œ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ Logger ì œê±°
        }
    });
```
ì´ˆê¸°ì—ëŠ” Loggerê°€ ë¬´ì œí•œ ìƒì„±ë˜ì–´ ë©”ëª¨ë¦¬ ë¬¸ì œê°€ ìˆì—ˆì§€ë§Œ, LRU ìºì‹œë¡œ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

### ì‹¤ì œ ìš´ì˜ ì¤‘ ë°œê²¬í•œ ì´ìŠˆì™€ í•´ê²°ì±…

#### ì´ìŠˆ 1: Hazelcast í´ëŸ¬ìŠ¤í„° ìŠ¤í”Œë¦¿ ë¸Œë ˆì¸
```yaml
# í•´ê²°: ìµœì†Œ í´ëŸ¬ìŠ¤í„° í¬ê¸° ê°•ì œ
hazelcast:
  cluster-name: logging-cluster
  properties:
    hazelcast.merge.first.run.delay.seconds: 5
    hazelcast.merge.next.run.delay.seconds: 5
  partition-group:
    enabled: true
    group-type: HOST_AWARE  # ê°™ì€ í˜¸ìŠ¤íŠ¸ ë‚´ ë°±ì—… ë°©ì§€
```

#### ì´ìŠˆ 2: log-subscriber OOM ë°œìƒ
**ì›ì¸**: ëŒ€ëŸ‰ ë¡œê·¸ ìœ ì… ì‹œ LogFileAdapterì˜ ë™ì  Logger ë¬´ì œí•œ ìƒì„±

```java
// í•´ê²°: Logger ìºì‹œ í¬ê¸° ì œí•œ + LRU ì •ì±…
private final Map<String, Logger> loggerCache = 
    Collections.synchronizedMap(new LinkedHashMap<String, Logger>(100, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, Logger> eldest) {
            if (size() > 100) {
                // ì˜¤ë˜ëœ Logger ì •ë¦¬
                Logger oldLogger = eldest.getValue();
                oldLogger.detachAndStopAllAppenders();
                return true;
            }
            return false;
        }
    });
```

#### ì´ìŠˆ 3: ë¡œê·¸ íŒŒì¼ ë””ìŠ¤í¬ í’€
**ì›ì¸**: ì••ì¶•ë˜ì§€ ì•Šì€ ë¡œê·¸ íŒŒì¼ ê¸‰ì† ì¦ê°€

```java
// í•´ê²°: ì‹¤ì‹œê°„ ì••ì¶• + ë” ê³µê²©ì ì¸ ìˆœí™˜ ì •ì±…
TimeBasedRollingPolicy rollingPolicy = new TimeBasedRollingPolicy();
rollingPolicy.setFileNamePattern(fileNamePattern);
rollingPolicy.setMaxHistory(3); // 7ì¼ â†’ 3ì¼ë¡œ ë‹¨ì¶•
rollingPolicy.setTotalSizeCap(FileSize.valueOf("10GB")); // ì „ì²´ í¬ê¸° ì œí•œ ì¶”ê°€
```

## 6. ë§ˆë¬´ë¦¬: í˜„ì‹¤ì ì¸ ê¶Œê³ ì‚¬í•­

### ë‹¨ê³„ë³„ ì ìš© ì „ëµ

1. **1ë‹¨ê³„**: ê¸°ì¡´ ì‹œìŠ¤í…œì— AsyncAppender ì ìš©
2. **2ë‹¨ê³„**: íŠ¸ë˜í”½ ì¦ê°€ ì‹œ Hazelcast ë„ì… ê²€í† 
3. **3ë‹¨ê³„**: ëŒ€ê·œëª¨ í™˜ê²½ì—ì„œ Kafka ë§ˆì´ê·¸ë ˆì´ì…˜

### ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] í˜„ì¬ ë¡œê¹…ëŸ‰ê³¼ TPS ì¸¡ì •
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ì²´ê³„ êµ¬ì¶•
- [ ] ë¡œê·¸ ìœ ì‹¤ í—ˆìš© ìˆ˜ì¤€ ì •ì˜
- [ ] ì¥ì•  ìƒí™© ëŒ€ì‘ ì ˆì°¨ ìˆ˜ë¦½
- [ ] ì„±ëŠ¥ ì„ê³„ì¹˜ ì•Œë¦¼ ì„¤ì •

---

**ì°¸ê³  ìë£Œ**
- [Logback AsyncAppender ê³µì‹ ë¬¸ì„œ](https://logback.qos.ch/manual/appenders.html#AsyncAppender)
- [Hazelcast ReliableTopic ê°€ì´ë“œ](https://docs.hazelcast.com/imdg/4.2/data-structures/reliable-topic)
- [Redis Streams vs Pub/Sub ë¹„êµ](https://redis.io/docs/data-types/streams/)

ì‹¤ë¬´ì—ì„œëŠ” ì™„ë²½í•œ ì†”ë£¨ì…˜ë³´ë‹¤ëŠ” **í˜„ì¬ ìƒí™©ì— ë§ëŠ” ìµœì  ì„ íƒ**ì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ ì‹œìŠ¤í…œ ê·œëª¨ì™€ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ì ì ˆí•œ ë°©ì‹ì„ ì„ íƒí•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.

*ì´ ê¸€ì´ ë„ì›€ì´ ë˜ì…¨ë‹¤ë©´ ëŒ“ê¸€ë¡œ ì—¬ëŸ¬ë¶„ì˜ ê²½í—˜ë„ ê³µìœ í•´ ì£¼ì„¸ìš”! ğŸš€*