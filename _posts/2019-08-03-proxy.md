---
title: Redis 단일 의존 탈피를 위한 프록시 패턴 도입기 - B2B 고객사별 캐시 엔진 요구사항 대응
date: 2025-07-13 10:00:00 +0900
categories: [Backend, Design-Pattern]
tags: [redis, proxy-pattern, spring-boot, b2b, architecture]
---

## 핵심 요약

B2B 서비스에서 고객사별로 다른 캐시 엔진 요구사항(Redis 전용, Hazelcast 선호, 클러스터 제약 등)에 대응하기 위해 프록시 패턴을 도입했습니다. CacheProxy를 통해 설정 변경만으로 캐시 엔진을 런타임에 전환할 수 있는 구조를 구축하여, 소스 코드 변경 없이 다양한 고객사 환경에 유연하게 대응할 수 있게 되었습니다.

## ⚠️ 문제 상황

### 초기 Redis 직접 의존 구조

```java
// 문제가 된 초기 코드 - Redis 직접 의존
@Service
public class ProductService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate; // Redis 강결합
    
    public Product getProduct(String productId) {
        // Lettuce 직접 사용으로 Redis에 종속
        String key = "product:" + productId;
        Product cached = (Product) redisTemplate.opsForValue().get(key);
        
        if (cached != null) {
            return cached;
        }
        
        Product product = productRepository.findById(productId);
        redisTemplate.opsForValue().set(key, product, Duration.ofHours(1));
        return product;
    }
}
```

### B2B 고객사별 요구사항

```yaml
# 고객사 A: Redis 클러스터만 허용
customer-a:
  cache:
    type: redis-cluster
    security: high
    
# 고객사 B: Hazelcast 선호 (기존 인프라와 통합)
customer-b:
  cache:
    type: hazelcast
    integration: existing-infrastructure
    
# 고객사 C: 단일 노드 제약 (비용 최적화)
customer-c:
  cache:
    type: redis-standalone
    nodes: single
```

**핵심 문제점:**
- **고객사별 배포 불가**: 서로 다른 캐시 엔진 요구사항
- **코드 중복**: 고객사별로 다른 캐시 로직 구현 필요
- **유지보수 복잡도**: 캐시 엔진 변경 시 전체 코드 수정

## 🔍 문제 분석

### 1. 멀티모듈 아키텍처 요구사항

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   User Service  │    │ Product Service │    │  Order Service  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────────┐
                    │   Cache Layer       │  ← 통일된 API 필요
                    └─────────────────────┘
                                 │
                    ┌─────────────────────┐
                    │ Redis / Hazelcast   │  ← 런타임 선택
                    └─────────────────────┘
```

### 2. Spring 빈 주입 시점 활용

```java
// 분석: Configuration에서 캐시 타입 결정
@Configuration
public class CacheConfiguration {
    
    @Value("${cache.type:redis}")
    private String cacheType;
    
    // 런타임에 구현체 선택 가능
    @Bean
    public CacheRepository cacheRepository() {
        return switch (cacheType) {
            case "redis" -> new RedisCacheRepository();
            case "hazelcast" -> new HazelcastCacheRepository();
            default -> throw new IllegalArgumentException("Unknown cache type: " + cacheType);
        };
    }
}
```

## ✅ 해결 방안

### 1. 공통 인터페이스 설계

```java
/**
 * 캐시 저장소 공통 인터페이스
 * - 캐시 엔진에 독립적인 추상화
 */
public interface CacheRepository<K, V> {
    Optional<V> get(K key);
    void put(K key, V value, Duration ttl);
    void evict(K key);
    void clear();
    boolean exists(K key);
}

/**
 * 캐시 서비스 공통 인터페이스
 * - 비즈니스 로직 레벨 추상화
 */
public interface CacheService<K, V> {
    Optional<V> getFromCache(K key);
    void putToCache(K key, V value, Duration ttl);
    void invalidateCache(K key);
    void invalidatePattern(String pattern);
}
```

### 2. CacheProxy 구현

```java
/**
 * 캐시 프록시 - 런타임 구현체 선택
 * Proxy Pattern 적용
 */
@Component
@Slf4j
public class CacheProxy<K, V> implements CacheRepository<K, V> {
    
    private final CacheRepository<K, V> delegateRepository;
    private final String cacheType;
    
    public CacheProxy(@Value("${cache.type:redis}") String cacheType,
                     ApplicationContext context) {
        this.cacheType = cacheType;
        this.delegateRepository = resolveCacheRepository(cacheType, context);
        
        log.info("Cache proxy initialized with type: {}", cacheType);
    }
    
    @Override
    public Optional<V> get(K key) {
        try {
            return delegateRepository.get(key);
        } catch (Exception e) {
            log.error("Cache get failed for key: {}, type: {}", key, cacheType, e);
            return Optional.empty();
        }
    }
    
    @Override
    public void put(K key, V value, Duration ttl) {
        try {
            delegateRepository.put(key, value, ttl);
            log.debug("Cache put successful - key: {}, type: {}", key, cacheType);
        } catch (Exception e) {
            log.error("Cache put failed for key: {}, type: {}", key, cacheType, e);
        }
    }
    
    @Override
    public void evict(K key) {
        try {
            delegateRepository.evict(key);
        } catch (Exception e) {
            log.error("Cache evict failed for key: {}, type: {}", key, cacheType, e);
        }
    }
    
    @Override
    public void clear() {
        try {
            delegateRepository.clear();
        } catch (Exception e) {
            log.error("Cache clear failed for type: {}", cacheType, e);
        }
    }
    
    @Override
    public boolean exists(K key) {
        try {
            return delegateRepository.exists(key);
        } catch (Exception e) {
            log.error("Cache exists check failed for key: {}, type: {}", key, cacheType, e);
            return false;
        }
    }
    
    private CacheRepository<K, V> resolveCacheRepository(String cacheType, 
                                                        ApplicationContext context) {
        return switch (cacheType.toLowerCase()) {
            case "redis" -> context.getBean("redisCacheRepository", CacheRepository.class);
            case "hazelcast" -> context.getBean("hazelcastCacheRepository", CacheRepository.class);
            case "local" -> context.getBean("localCacheRepository", CacheRepository.class);
            default -> throw new IllegalArgumentException("Unsupported cache type: " + cacheType);
        };
    }
}
```

### 3. Redis 구현체

```java
/**
 * Redis 캐시 저장소 구현
 */
@Repository("redisCacheRepository")
@Slf4j
public class RedisCacheRepository<K, V> implements CacheRepository<K, V> {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    public RedisCacheRepository(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
        this.objectMapper = new ObjectMapper()
                .registerModule(new JavaTimeModule());
    }
    
    @Override
    public Optional<V> get(K key) {
        try {
            String redisKey = convertKey(key);
            Object cached = redisTemplate.opsForValue().get(redisKey);
            
            if (cached == null) {
                return Optional.empty();
            }
            
            // JSON 역직렬화
            V value = deserializeValue(cached.toString());
            return Optional.of(value);
            
        } catch (Exception e) {
            log.error("Redis get operation failed", e);
            return Optional.empty();
        }
    }
    
    @Override
    public void put(K key, V value, Duration ttl) {
        try {
            String redisKey = convertKey(key);
            String jsonValue = objectMapper.writeValueAsString(value);
            
            if (ttl != null && !ttl.isZero()) {
                redisTemplate.opsForValue().set(redisKey, jsonValue, ttl);
            } else {
                redisTemplate.opsForValue().set(redisKey, jsonValue);
            }
            
        } catch (Exception e) {
            log.error("Redis put operation failed", e);
        }
    }
    
    @Override
    public void evict(K key) {
        try {
            String redisKey = convertKey(key);
            redisTemplate.delete(redisKey);
        } catch (Exception e) {
            log.error("Redis evict operation failed", e);
        }
    }
    
    @Override
    public void clear() {
        try {
            // 패턴 기반 삭제 (주의: 운영 환경에서는 성능 고려 필요)
            Set<String> keys = redisTemplate.keys("cache:*");
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
            }
        } catch (Exception e) {
            log.error("Redis clear operation failed", e);
        }
    }
    
    @Override
    public boolean exists(K key) {
        try {
            String redisKey = convertKey(key);
            return Boolean.TRUE.equals(redisTemplate.hasKey(redisKey));
        } catch (Exception e) {
            log.error("Redis exists check failed", e);
            return false;
        }
    }
    
    private String convertKey(K key) {
        return "cache:" + key.toString();
    }
    
    @SuppressWarnings("unchecked")
    private V deserializeValue(String jsonValue) throws Exception {
        // 실제 구현에서는 타입 정보를 활용한 역직렬화
        return (V) objectMapper.readValue(jsonValue, Object.class);
    }
}
```

### 4. Hazelcast 구현체

```java
/**
 * Hazelcast 캐시 저장소 구현
 */
@Repository("hazelcastCacheRepository")
@Slf4j
public class HazelcastCacheRepository<K, V> implements CacheRepository<K, V> {
    
    private final HazelcastInstance hazelcastInstance;
    private final IMap<String, Object> cacheMap;
    
    public HazelcastCacheRepository(HazelcastInstance hazelcastInstance) {
        this.hazelcastInstance = hazelcastInstance;
        this.cacheMap = hazelcastInstance.getMap("default-cache");
    }
    
    @Override
    public Optional<V> get(K key) {
        try {
            String mapKey = convertKey(key);
            Object cached = cacheMap.get(mapKey);
            
            if (cached == null) {
                return Optional.empty();
            }
            
            @SuppressWarnings("unchecked")
            V value = (V) cached;
            return Optional.of(value);
            
        } catch (Exception e) {
            log.error("Hazelcast get operation failed", e);
            return Optional.empty();
        }
    }
    
    @Override
    public void put(K key, V value, Duration ttl) {
        try {
            String mapKey = convertKey(key);
            
            if (ttl != null && !ttl.isZero()) {
                cacheMap.put(mapKey, value, ttl.getSeconds(), TimeUnit.SECONDS);
            } else {
                cacheMap.put(mapKey, value);
            }
            
        } catch (Exception e) {
            log.error("Hazelcast put operation failed", e);
        }
    }
    
    @Override
    public void evict(K key) {
        try {
            String mapKey = convertKey(key);
            cacheMap.remove(mapKey);
        } catch (Exception e) {
            log.error("Hazelcast evict operation failed", e);
        }
    }
    
    @Override
    public void clear() {
        try {
            cacheMap.clear();
        } catch (Exception e) {
            log.error("Hazelcast clear operation failed", e);
        }
    }
    
    @Override
    public boolean exists(K key) {
        try {
            String mapKey = convertKey(key);
            return cacheMap.containsKey(mapKey);
        } catch (Exception e) {
            log.error("Hazelcast exists check failed", e);
            return false;
        }
    }
    
    private String convertKey(K key) {
        return "cache:" + key.toString();
    }
}
```

### 5. 설정 기반 캐시 전환

```yaml
# application-redis.yml
cache:
  type: redis
  
spring:
  data:
    redis:
      host: localhost
      port: 6379
      
---
# application-hazelcast.yml  
cache:
  type: hazelcast
  
hazelcast:
  cluster-name: dev-cluster
  members: localhost:5701
```

### 6. 개선된 서비스 레이어

```java
/**
 * 개선된 ProductService - 캐시 엔진에 독립적
 */
@Service
@Slf4j
public class ProductService {
    
    private final CacheRepository<String, Product> cacheRepository;
    private final ProductRepository productRepository;
    
    // 인터페이스에 의존, 구현체는 런타임에 주입
    public ProductService(CacheRepository<String, Product> cacheRepository,
                         ProductRepository productRepository) {
        this.cacheRepository = cacheRepository;
        this.productRepository = productRepository;
    }
    
    public Product getProduct(String productId) {
        String cacheKey = "product:" + productId;
        
        // 캐시 엔진에 관계없이 동일한 API 사용
        Optional<Product> cached = cacheRepository.get(cacheKey);
        if (cached.isPresent()) {
            log.debug("Cache hit for product: {}", productId);
            return cached.get();
        }
        
        // DB 조회
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new EntityNotFoundException("Product not found: " + productId));
        
        // 캐시 저장 (1시간 TTL)
        cacheRepository.put(cacheKey, product, Duration.ofHours(1));
        
        log.info("Product loaded from DB and cached: {}", productId);
        return product;
    }
    
    public void updateProduct(Product product) {
        // DB 업데이트
        productRepository.save(product);
        
        // 캐시 무효화
        String cacheKey = "product:" + product.getProductId();
        cacheRepository.evict(cacheKey);
        
        log.info("Product updated and cache invalidated: {}", product.getProductId());
    }
}
```

## 📊 성과 및 효과

### 캐시 엔진 전환 테스트

```java
@SpringBootTest
class CacheProxyIntegrationTest {
    
    @Autowired
    private CacheRepository<String, String> cacheRepository;
    
    @Test
    @TestPropertySource(properties = "cache.type=redis")
    void testRedisCache() {
        // Redis 캐시 테스트
        String key = "test:redis";
        String value = "redis-value";
        
        cacheRepository.put(key, value, Duration.ofMinutes(1));
        Optional<String> result = cacheRepository.get(key);
        
        assertThat(result).isPresent();
        assertThat(result.get()).isEqualTo(value);
    }
    
    @Test  
    @TestPropertySource(properties = "cache.type=hazelcast")
    void testHazelcastCache() {
        // Hazelcast 캐시 테스트
        String key = "test:hazelcast";
        String value = "hazelcast-value";
        
        cacheRepository.put(key, value, Duration.ofMinutes(1));
        Optional<String> result = cacheRepository.get(key);
        
        assertThat(result).isPresent();
        assertThat(result.get()).isEqualTo(value);
    }
}
```

### 고객사별 배포 성공

```bash
# 고객사 A: Redis 배포
docker run -e SPRING_PROFILES_ACTIVE=redis app:latest

# 고객사 B: Hazelcast 배포  
docker run -e SPRING_PROFILES_ACTIVE=hazelcast app:latest

# 동일한 애플리케이션 바이너리로 다른 캐시 엔진 사용
```

## 핵심 성과

1. **코드 변경 없는 캐시 전환**: application.yml 한 줄로 Redis ↔ Hazelcast 전환
2. **고객사별 유연한 대응**: 동일한 바이너리로 다양한 캐시 환경 지원
3. **개발 생산성 향상**: 캐시 로직 추상화로 비즈니스 로직에 집중
4. **유지보수성 개선**: 새로운 캐시 엔진 추가 시 구현체만 추가하면 됨

프록시 패턴 도입을 통해 B2B 서비스의 복잡한 고객사 요구사항에 유연하게 대응할 수 있는 확장 가능한 캐시 아키텍처를 구축할 수 있었습니다.

---

*본 글은 실제 B2B 서비스 개발 경험을 바탕으로 작성되었으며, 프록시 패턴의 실무 적용 사례를 소개합니다.*